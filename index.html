<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Static Live Chat â€“ Final Integrated Version</title>
  <!-- Firebase Scripts -->
  <script src="https://www.gstatic.com/firebasejs/11.5.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.5.0/firebase-database-compat.js"></script>
  <style>
    /* ========== Theme Variables ========== */
    :root {
      --bg-color: #111;
      --text-color: #fff;
      --sidebar-color: #1c1c1c;
      --chat-bg: #222;
      --bubble-to: #1e90ff;
      --bubble-from: #444;
      --bubble-console: rgba(255, 255, 255, 0.2);
      --accent: #1e90ff;
      --badge: red;
      --chat-item-bg: #333;
      --font-size-msg: 17px;
      --shadow-msg: 0px 2px 4px rgba(0, 0, 0, 0.3);
    }
    body.light {
      --bg-color: #f4f4f4;
      --text-color: #000;
      --sidebar-color: #ddd;
      --chat-bg: #eee;
      --bubble-to: #007aff;
      --bubble-from: #ccc;
      --bubble-console: rgba(0, 0, 0, 0.1);
      --accent: #007acc;
      --chat-item-bg: #bbb;
    }
    body.blue {
      --bg-color: #0b1622;
      --text-color: #f0f8ff;
      --sidebar-color: #132336;
      --chat-bg: #1e2d40;
      --bubble-to: #1f65ff;
      --bubble-from: #41546a;
      --bubble-console: rgba(255, 255, 255, 0.2);
      --accent: #389fff;
      --chat-item-bg: #2e3d52;
    }
    body.green {
      --bg-color: #102a10;
      --text-color: #e8ffe8;
      --sidebar-color: #224522;
      --chat-bg: #1a331a;
      --bubble-to: #28a745;
      --bubble-from: #375a37;
      --bubble-console: rgba(255, 255, 255, 0.2);
      --accent: #4caf50;
      --chat-item-bg: #2b442b;
    }
    body.pink {
      --bg-color: #331024;
      --text-color: #ffe0f0;
      --sidebar-color: #441533;
      --chat-bg: #551a44;
      --bubble-to: #ff3377;
      --bubble-from: #773355;
      --bubble-console: rgba(255, 255, 255, 0.2);
      --accent: #ff66a2;
      --chat-item-bg: #442244;
    }
    body.purple {
      --bg-color: #2e1033;
      --text-color: #f4e4ff;
      --sidebar-color: #42154a;
      --chat-bg: #551a66;
      --bubble-to: #9b59b6;
      --bubble-from: #7e3f9f;
      --bubble-console: rgba(255, 255, 255, 0.2);
      --accent: #b86af1;
      --chat-item-bg: #4d1460;
    }
    
    /* ========== Global Styles ========== */
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: var(--bg-color);
      color: var(--text-color);
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    input, button {
      padding: 10px;
      font-size: 16px;
      margin: 5px;
      border-radius: 6px;
      border: none;
    }
    button {
      background: var(--accent);
      color: #fff;
      cursor: pointer;
    }
    
    /* ========== Layout ========== */
    #app {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    #sidebar {
      width: 280px;
      background: var(--sidebar-color);
      display: flex;
      flex-direction: column;
      padding: 10px;
      overflow-y: auto;
    }
    #chatPanel {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: var(--chat-bg);
      position: relative;
    }
    /* Fixed header and input; only messages scroll */
    #topBar, #inputArea {
      flex-shrink: 0;
    }
    #topBar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      font-size: 18px;
      background: var(--chat-bg);
    }
    #topBar .top-right {
      display: flex;
      gap: 5px;
    }
    #chatTitle {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    #messages {
      flex: 1;
      padding: 15px;
      overflow-y: auto;
      background: var(--chat-bg);
    }
    
    /* ========== Message Bubbles ========== */
    .msg {
      max-width: 70%;
      padding: 12px 20px;
      margin: 6px;
      border-radius: 9999px;
      font-size: var(--font-size-msg);
      line-height: 1.4;
      word-wrap: break-word;
      position: relative;
      cursor: pointer;
      box-shadow: var(--shadow-msg);
      background-clip: padding-box;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .msg p {
      margin: 0;
      text-align: center;
    }
    .to {
      align-self: flex-end;
      background: var(--bubble-to);
      color: #fff;
    }
    .from {
      align-self: flex-start;
      background: var(--bubble-from);
      color: #fff;
    }
    .console {
      align-self: center;
      background: var(--bubble-console);
      font-style: italic;
    }
    .reactionTag {
      font-size: 14px;
      opacity: 0.8;
      position: absolute;
      top: 5px;
      right: 10px;
    }
    .reactionBar {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      flex-direction: row;
      gap: 5px;
      background: rgba(0,0,0,0.6);
      padding: 5px;
      border-radius: 6px;
      margin-bottom: 5px;
    }
    .reactionBar span {
      font-size: 22px;
      cursor: pointer;
    }
    .timestamp {
      font-size: 10px;
      opacity: 0.7;
      margin-top: 4px;
      text-align: right;
    }
    
    /* ========== Input Area ========== */
    #typingIndicator {
      display: none;
      font-style: italic;
      font-size: 14px;
      margin: 0 20px 10px;
    }
    #inputArea {
      display: flex;
      padding: 10px;
      background: var(--sidebar-color);
    }
    #inputArea input {
      flex: 1;
      margin-right: 5px;
      font-size: 17px;
    }
    
    /* ========== Utility Panels ========== */
    #emojiPicker {
      display: none;
      position: absolute;
      bottom: 70px;
      right: 15px;
      background: var(--chat-bg);
      padding: 10px;
      flex-wrap: wrap;
      z-index: 99;
      max-width: 340px;
      max-height: 180px;
      overflow: auto;
    }
    #emojiPicker span {
      font-size: 22px;
      margin: 6px;
      cursor: pointer;
    }
    .chatItem {
      background: var(--chat-item-bg);
      padding: 10px;
      border-radius: 6px;
      margin-bottom: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      transition: background 0.2s;
      position: relative;
    }
    .chatItem:hover {
      background: var(--bubble-from);
    }
    .chatItem.active {
      outline: 2px solid var(--accent);
    }
    .chatBadge {
      background: var(--badge);
      color: #fff;
      font-size: 12px;
      padding: 3px 8px;
      border-radius: 12px;
      margin-left: 5px;
    }
    .requestItem {
      background: var(--bubble-from);
      padding: 10px;
      margin-bottom: 5px;
      border-radius: 6px;
    }
    .friendMenu {
      position: absolute;
      background: var(--chat-bg);
      padding: 6px;
      border-radius: 6px;
      display: none;
      z-index: 100;
    }
    .friendMenu button {
      display: block;
      width: 100%;
      text-align: left;
      margin: 2px 0;
    }
    #staticMenu {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: #1e1e1e;
      color: #fff;
      padding: 5px 8px;
      border-radius: 8px;
      font-size: 13px;
      box-shadow: 0 0 6px #0ff;
      animation: blink 2s infinite;
      z-index: 1000;
    }
    a.staticLink {
      color: #0ff;
      text-decoration: none;
    }
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    
    /* ========== Modal Styles ========== */
    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 999;
    }
    .modalContent {
      background: var(--chat-bg);
      padding: 20px;
      border-radius: 10px;
      max-width: 400px;
      position: relative;
      text-align: center;
    }
    .closeBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: red;
      color: #fff;
      border: none;
      cursor: pointer;
      border-radius: 4px;
      padding: 3px 8px;
    }
    
    /* ========== Notification Container ========== */
    #notificationContainer {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1100;
    }
    .notification {
      background: var(--accent);
      color: #fff;
      padding: 10px 20px;
      margin: 5px;
      border-radius: 6px;
      opacity: 0.9;
      font-size: 16px;
      box-shadow: var(--shadow-msg);
      transition: opacity 0.5s;
    }
    
    /* ========== Login Screen ========== */
    #login {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.7);
      z-index: 999;
    }
    
    /* ========== Slash Autocomplete ========== */
    #slashAutocomplete {
      display: none;
      position: absolute;
      background: var(--chat-bg);
      border-radius: 6px;
      padding: 5px;
      max-width: 220px;
      z-index: 9999;
    }
    #slashAutocomplete button {
      width: 100%;
      display: block;
      text-align: left;
      margin: 5px 0;
      padding: 6px;
      border-radius: 4px;
      border: none;
      background: var(--accent);
      cursor: pointer;
    }
    #loadMoreBtn {
      display: none;
      position: absolute;
      top: 15px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--accent);
      color: #fff;
      border: none;
      border-radius: 6px;
      padding: 5px;
      cursor: pointer;
      opacity: 0.8;
      z-index: 10;
    }
  </style>
  <script>
    // ========== Firebase Initialization ==========
    const firebaseConfig = {
      apiKey: "AIzaSyBO7EHU4-_b2NHf7UFYTB8Wolv73Z0P8Fw",
      authDomain: "static-live-chatting.firebaseapp.com",
      databaseURL: "https://static-live-chatting-default-rtdb.firebaseio.com",
      projectId: "static-live-chatting",
      storageBucket: "static-live-chatting.appspot.com",
      messagingSenderId: "578562140653",
      appId: "1:578562140653:web:c12df07155627083e9dfe4"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    
    // ========== Helper Functions ==========
    function showNotice(msg) {
      const container = document.getElementById("notificationContainer");
      const note = document.createElement("div");
      note.className = "notification";
      note.textContent = msg;
      container.appendChild(note);
      setTimeout(() => { note.style.opacity = 0; }, 3000);
      setTimeout(() => { container.removeChild(note); }, 3500);
    }
    function showConfirm(msg) {
      return new Promise(resolve => {
        const container = document.createElement("div");
        container.className = "modal";
        container.style.display = "flex";
        container.innerHTML = `
          <div class="modalContent">
            <h3>Confirm</h3>
            <p>${msg}</p>
            <button id="yesBtn" style="background:green;">Yes</button>
            <button id="noBtn" style="background:red;">No</button>
          </div>
        `;
        document.body.appendChild(container);
        container.querySelector("#yesBtn").onclick = () => {
          document.body.removeChild(container);
          resolve(true);
        };
        container.querySelector("#noBtn").onclick = () => {
          document.body.removeChild(container);
          resolve(false);
        };
      });
    }
    function debounce(func, delay) {
      let timeoutId;
      return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
      };
    }
    const debouncedUpdateTitle = debounce(() => {
      const totalUnread = Object.values(chatUnread).reduce((a, b) => a + b, 0);
      document.title = totalUnread > 0 ? `(+${totalUnread}) Static Live Chat` : "Static Live Chat";
    }, 300);
    const debouncedUpdateChatListUI = debounce(updateChatListUI, 300);
    
    // ========== Device & User Setup ==========
    function genId() { return "dev_" + Math.random().toString(36).slice(2) + "_" + Date.now(); }
    let myId = localStorage.getItem("myDeviceId");
    if (!myId) { myId = genId(); localStorage.setItem("myDeviceId", myId); }
    let displayName = localStorage.getItem("displayName") || "";
    let pass = localStorage.getItem("pass") || "";
    
    // ========== Global Variables ==========
    let currentChat = "", currentType = "";
    let messagesRef = null, childAddedRef = null, childChangedRef = null;
    let oldestStamp = Number.MAX_SAFE_INTEGER, hasMoreOld = false;
    let chatUnread = {};
    let blocked = {}, friends = {};
    let lastMessageTime = 0;
    const slashCmds = [
      "/roll", "/ping", "/8ball", "/roast", "/tod truth", "/tod dare",
      "/title", "/cf heads", "/cf tails", "/coin flip heads", "/coin flip tails",
      "/ship", "/rps", "/guessnumber", "/vote"
    ];
    
    // ========== Auto-Scroll Function ==========
    function autoScroll() {
      const area = document.getElementById("messages");
      const tolerance = 50;
      if (area.scrollTop + area.clientHeight >= area.scrollHeight - tolerance) {
        area.scrollTop = area.scrollHeight;
      }
    }
    
    // ========== On Load ==========
    window.addEventListener("DOMContentLoaded", () => {
      document.addEventListener("keydown", function(e) {
        if (e.key === "Escape") {
          document.querySelectorAll(".modal").forEach(modal => { modal.style.display = "none"; });
        }
      });
      document.addEventListener("click", function(e) {
        document.querySelectorAll(".modal").forEach(modal => {
          if (modal.style.display === "flex" && e.target === modal) { modal.style.display = "none"; }
        });
      });
      if (displayName) {
        document.getElementById("login").style.display = "none";
        document.getElementById("app").style.display = "flex";
        applyTheme();
        loadBlocked();
        loadFriends();
        loadRequests();
        initChatWatchers();
      }
    });
    
    // ========== Theme Functions ==========
    function applyTheme() {
      const theme = localStorage.getItem("theme") || "dark";
      document.body.className = "";
      if (theme !== "dark") { document.body.classList.add(theme); }
      setThemeLabel(theme);
    }
    function toggleTheme() {
      const themes = ["dark", "light", "blue", "green", "pink", "purple"];
      let current = "dark";
      themes.forEach(t => { if (document.body.classList.contains(t)) current = t; });
      let idx = themes.indexOf(current);
      let next = themes[(idx + 1) % themes.length];
      document.body.className = "";
      if (next !== "dark") { document.body.classList.add(next); }
      localStorage.setItem("theme", next);
      setThemeLabel(next);
    }
    function setThemeLabel(lab) {
      document.getElementById("themeBtn").textContent = lab + ": Theme";
    }
    
    // ========== Login & Settings ==========
    function toggleLoginPass() {
      let pw = document.getElementById("password");
      pw.type = (pw.type === "password") ? "text" : "password";
    }
    function doLogin() {
      let nm = document.getElementById("username").value.trim();
      let p = document.getElementById("password").value.trim();
      if (!nm) { showNotice("Name can't be empty!"); return; }
      db.ref("displayNames/" + nm).once("value", snap => {
        let val = snap.val();
        if (val && val !== myId) {
          showNotice("That display name is used by another device. Try another name.");
          return;
        }
        displayName = nm; pass = p;
        localStorage.setItem("displayName", nm);
        localStorage.setItem("pass", p);
        db.ref("displayNames/" + nm).set(myId);
        db.ref("users/" + myId + "/displayName").set(nm);
        document.getElementById("login").style.display = "none";
        document.getElementById("app").style.display = "flex";
        applyTheme();
        loadBlocked();
        loadFriends();
        loadRequests();
        initChatWatchers();
        showNotice("Logged in as " + nm);
      });
    }
    function openSettings() {
      let mo = document.createElement("div");
      mo.className = "modal";
      mo.innerHTML = `
        <div class="modalContent" style="min-width:320px;">
          <button class="closeBtn" onclick="document.body.removeChild(this.parentElement.parentElement)">X</button>
          <h3>Settings</h3>
          <label>Display Name:</label><br/>
          <input id="editName" value="${displayName}"/><br/>
          <label>Password (for friend requests):</label><br/>
          <input id="editPass" value="${pass}"/><br/>
          <button id="saveSetBtn">Save</button>
          <hr/>
          <h4>Blocked Users</h4>
          <div id="blockedList"></div>
          <hr/>
          <button id="logoutBtn" style="background:darkred;">Log Out</button>
        </div>
      `;
      document.body.appendChild(mo);
      mo.style.display = "flex";
      mo.addEventListener("click", ev => { if (ev.target === mo) mo.style.display = "none"; });
      mo.querySelector("#saveSetBtn").onclick = () => {
        let newN = mo.querySelector("#editName").value.trim();
        let newP = mo.querySelector("#editPass").value.trim();
        if (!newN) { showNotice("Name can't be empty!"); return; }
        db.ref("displayNames/" + newN).once("value", snap => {
          let val = snap.val();
          if (val && val !== myId) {
            showNotice("That name is taken by another device. Try another name.");
            return;
          }
          displayName = newN; pass = newP;
          localStorage.setItem("displayName", newN);
          localStorage.setItem("pass", newP);
          db.ref("displayNames/" + newN).set(myId);
          db.ref("users/" + myId + "/displayName").set(newN);
          showNotice("Settings saved!");
          mo.style.display = "none";
        });
      };
      mo.querySelector("#logoutBtn").onclick = () => {
        showConfirm("Are you sure you want to log out?").then(ok => {
          if (ok) {
            localStorage.removeItem("myDeviceId");
            localStorage.removeItem("displayName");
            localStorage.removeItem("pass");
            location.reload();
          }
        });
      };
      loadBlockedForSettings(mo.querySelector("#blockedList"));
    }
    function loadBlockedForSettings(container) {
      db.ref("users/" + myId + "/blocked").once("value", snap => {
        let list = snap.val() || {};
        container.innerHTML = "";
        if (Object.keys(list).length === 0) container.textContent = "No blocked users.";
        else {
          Object.keys(list).forEach(user => {
            let div = document.createElement("div");
            div.textContent = user;
            let unblk = document.createElement("button");
            unblk.textContent = "Unblock";
            unblk.onclick = () => {
              db.ref("users/" + myId + "/blocked/" + user).remove();
              showNotice(user + " has been unblocked.");
              loadBlockedForSettings(container);
            };
            div.appendChild(unblk);
            container.appendChild(div);
          });
        }
      });
    }
    
    // ========== Friends & Chat Panels ==========
    function openFriendsPanel() {
      let mo = document.createElement("div");
      mo.className = "modal";
      mo.innerHTML = `
        <div class="modalContent" style="max-height:400px; overflow:auto; min-width:300px;">
          <button class="closeBtn" onclick="document.body.removeChild(this.parentElement.parentElement)">X</button>
          <h3>Your Friends</h3>
          <div id="frList"></div>
        </div>
      `;
      document.body.appendChild(mo);
      mo.style.display = "flex";
      mo.addEventListener("click", ev => { if (ev.target === mo) mo.style.display = "none"; });
      let fl = mo.querySelector("#frList");
      if (!friends || !Object.keys(friends).length) fl.textContent = "No friends yet!";
      else {
        Object.keys(friends).forEach(n => {
          let d = document.createElement("div");
          d.style.background = "var(--chat-bg)";
          d.style.padding = "8px";
          d.style.marginBottom = "8px";
          d.style.borderRadius = "6px";
          d.textContent = n;
          let btn = document.createElement("button");
          btn.textContent = "â‹®";
          btn.style.marginLeft = "10px";
          btn.style.cursor = "pointer";
          let menu = document.createElement("div");
          menu.className = "friendMenu";
          menu.style.left = "calc(100% + 5px)";
          menu.style.top = "0px";
          let openBtn = document.createElement("button");
          openBtn.textContent = "Open Chat";
          openBtn.onclick = () => {
            db.ref("displayNames/" + n).once("value", snap => {
              let dev = snap.val();
              if (!dev) { showNotice("User not found!"); return; }
              let cid = [myId, dev].sort().join("_");
              db.ref("privateChats/" + cid).once("value", snap2 => {
                if (!snap2.exists()) {
                  db.ref("privateChats/" + cid).set({
                    members: { [myId]: true, [dev]: true },
                    createdAt: Date.now()
                  });
                }
              });
              db.ref("users/" + myId + "/chats/" + cid).set({ name: n, type: "private", last: Date.now() });
              openChat(cid, n, "private");
            });
            menu.style.display = "none";
          };
          menu.appendChild(openBtn);
          let unfriendBtn = document.createElement("button");
          unfriendBtn.textContent = "Unfriend";
          unfriendBtn.onclick = () => {
            showConfirm("Unfriend " + n + "?").then(ok => {
              if (ok) {
                db.ref("users/" + myId + "/friends/" + n).remove();
                db.ref("displayNames/" + n).once("value", snap => {
                  let dev = snap.val();
                  if (dev) { db.ref("users/" + dev + "/friends/" + displayName).remove(); }
                });
                showNotice("Unfriended " + n);
              }
            });
            menu.style.display = "none";
          };
          menu.appendChild(unfriendBtn);
          let blockBtn = document.createElement("button");
          blockBtn.textContent = "Block";
          blockBtn.onclick = () => {
            showConfirm("Block " + n + "?").then(ok => {
              if (ok) { db.ref("users/" + myId + "/blocked/" + n).set(true); showNotice("Blocked " + n); }
            });
            menu.style.display = "none";
          };
          menu.appendChild(blockBtn);
          btn.onclick = ev => {
            ev.stopPropagation();
            menu.style.display = (menu.style.display === "flex") ? "none" : "flex";
          };
          d.appendChild(btn);
          d.appendChild(menu);
          fl.appendChild(d);
        });
      }
    }
    function addFriendUI() {
      let mo = document.createElement("div");
      mo.className = "modal";
      mo.innerHTML = `
        <div class="modalContent" style="min-width:300px;">
          <button class="closeBtn" onclick="document.body.removeChild(this.parentElement.parentElement)">X</button>
          <h3>Add Friend by Name</h3>
          <input id="friendNameInput" placeholder="Friend's display name"/><br/>
          <button id="friendSendBtn">Send Request</button>
        </div>
      `;
      document.body.appendChild(mo);
      mo.style.display = "flex";
      mo.addEventListener("click", ev => { if (ev.target === mo) mo.style.display = "none"; });
      mo.querySelector("#friendSendBtn").onclick = () => {
        let n = mo.querySelector("#friendNameInput").value.trim();
        if (!n) { showNotice("Please enter a name."); return; }
        if (n === displayName) { showNotice("You cannot friend yourself."); return; }
        if (blocked[n]) { showNotice("Unblock the user first."); return; }
        db.ref("displayNames/" + n).once("value", snap => {
          let dev = snap.val();
          if (!dev) { showNotice("No user with that name found."); return; }
          if (friends[n]) { showNotice("You're already friends with " + n + "!"); return; }
          db.ref(`users/${myId}/requestsSent/${n}`).once("value", s2 => {
            if (s2.exists()) { showNotice("Already pending request."); return; }
            db.ref(`users/${dev}/requests/${displayName}`).set({ requested: true });
            db.ref(`users/${myId}/requestsSent/${n}`).set(true);
            db.ref(`privateChats/${[myId, dev].sort().join("_")}`).set({});
            showNotice("Friend request sent to " + n);
            document.body.removeChild(mo);
          });
        });
      };
    }
    
    // ========== Group Chat Functions ==========
    function showAddChatPanel() {
      let mo = document.createElement("div");
      mo.className = "modal";
      mo.innerHTML = `
        <div class="modalContent" style="min-width:320px;">
          <button class="closeBtn" onclick="document.body.removeChild(this.parentElement.parentElement)">X</button>
          <h3>Add Chat</h3>
          <button onclick="showCreatePanel();document.body.removeChild(this.closest('.modal'))">Create Group</button><br/>
          <button onclick="showJoinPanel();document.body.removeChild(this.closest('.modal'))">Join Group</button><br/>
          <button onclick="showPublicDirectory();document.body.removeChild(this.closest('.modal'))">Open Groups</button>
        </div>
      `;
      document.body.appendChild(mo);
      mo.style.display = "flex";
      mo.addEventListener("click", ev => { if (ev.target === mo) mo.style.display = "none"; });
    }
    function showCreatePanel() {
      let mo = document.createElement("div");
      mo.className = "modal";
      mo.innerHTML = `
        <div class="modalContent" style="min-width:300px;">
          <button class="closeBtn" onclick="document.body.removeChild(this.parentElement.parentElement)">X</button>
          <h3>Create Group</h3>
          <input id="groupName" placeholder="Group Name"/><br/>
          <select id="groupType">
            <option value="open">Open</option>
            <option value="password">Password</option>
            <option value="invite">Invite Only</option>
          </select><br/>
          <input id="groupPassword" placeholder="Password (optional)"/><br/>
          <button id="createGroupBtn">Create</button>
        </div>
      `;
      document.body.appendChild(mo);
      mo.style.display = "flex";
      mo.addEventListener("click", e => { if (e.target === mo) mo.style.display = "none"; });
      mo.querySelector("#createGroupBtn").onclick = () => {
        let nm = mo.querySelector("#groupName").value.trim();
        let ty = mo.querySelector("#groupType").value;
        let pw = mo.querySelector("#groupPassword").value.trim();
        if (!nm) { showNotice("Group name cannot be empty."); return; }
        let gid = "group_" + Date.now();
        db.ref("groupChats/" + gid).set({
          name: nm,
          type: ty,
          password: pw,
          createdBy: myId,
          members: { [myId]: true }
        });
        db.ref("users/" + myId + "/chats/" + gid).set({ name: nm, type: "group", last: Date.now() });
        showNotice("Group chat created.");
        document.body.removeChild(mo);
        openChat(gid, nm, "group");
      };
    }
    function showJoinPanel() {
      let mo = document.createElement("div");
      mo.className = "modal";
      mo.innerHTML = `
        <div class="modalContent" style="min-width:300px;">
          <button class="closeBtn" onclick="document.body.removeChild(this.parentElement.parentElement)">X</button>
          <h3>Join Group Chat</h3>
          <input id="joinGroupID" placeholder="Group ID"/><br/>
          <input id="joinGroupPassword" placeholder="Password (if needed)"/><br/>
          <button id="joinGroupBtn">Join</button>
        </div>
      `;
      document.body.appendChild(mo);
      mo.style.display = "flex";
      mo.addEventListener("click", e => { if (e.target === mo) mo.style.display = "none"; });
      mo.querySelector("#joinGroupBtn").onclick = () => {
        let id = mo.querySelector("#joinGroupID").value.trim();
        let pw = mo.querySelector("#joinGroupPassword").value.trim();
        if (!id) { showNotice("Group ID is required."); return; }
        db.ref("groupChats/" + id).once("value", snap => {
          let g = snap.val();
          if (!g) { showNotice("Group not found."); return; }
          if (g.type === "password" && g.password !== pw) { showNotice("Incorrect password."); return; }
          if (g.type === "invite" && !(g.members && g.members[myId])) { showNotice("You are not invited to this group."); return; }
          db.ref("groupChats/" + id + "/members/" + myId).set(true);
          db.ref("users/" + myId + "/chats/" + id).set({ name: g.name, type: "group", last: Date.now() });
          document.body.removeChild(mo);
          openChat(id, g.name, "group");
        });
      };
    }
    function showPublicDirectory() {
      let mo = document.createElement("div");
      mo.className = "modal";
      mo.innerHTML = `
        <div class="modalContent">
          <button class="closeBtn" onclick="document.body.removeChild(this.parentElement.parentElement)">X</button>
          <h3>Public Groups</h3>
          <div id="publicList" style="max-height:200px; overflow:auto;"></div>
        </div>
      `;
      document.body.appendChild(mo);
      mo.style.display = "flex";
      mo.addEventListener("click", e => { if (e.target === mo) mo.style.display = "none"; });
      db.ref("groupChats").once("value", snap => {
        let data = snap.val() || {};
        let pl = mo.querySelector("#publicList");
        pl.innerHTML = "";
        Object.entries(data).forEach(([gid, g]) => {
          if (g.type === "open") {
            let btn = document.createElement("button");
            btn.textContent = `${g.name} (${gid})`;
            btn.onclick = () => {
              db.ref("groupChats/" + gid + "/members/" + myId).set(true);
              db.ref("users/" + myId + "/chats/" + gid).set({ name: g.name, type: "group", last: Date.now() });
              document.body.removeChild(mo);
              openChat(gid, g.name, "group");
            };
            pl.appendChild(btn);
            pl.appendChild(document.createElement("br"));
          }
        });
      });
    }
    
    // ========== Chat & Message Watchers ==========
    function loadRequests() {
      db.ref("users/" + myId + "/requests").on("value", snap => {
        let data = snap.val() || {};
        let tab = document.getElementById("requestsTab");
        tab.innerHTML = "";
        Object.keys(data).forEach(from => {
          let di = document.createElement("div");
          di.className = "requestItem";
          di.textContent = `${from} wants to chat. `;
          let accept = document.createElement("button");
          accept.textContent = "âœ”";
          accept.style.background = "green";
          accept.onclick = () => {
            if (blocked[from]) { showNotice("Unblock them first!"); return; }
            db.ref("displayNames/" + from).once("value", snap => {
              let dev = snap.val();
              if (!dev) { showNotice("User not found!"); return; }
              let cid = [myId, dev].sort().join("_");
              db.ref("privateChats/" + cid).once("value", snap2 => {
                if (!snap2.exists()) {
                  db.ref("privateChats/" + cid).set({
                    members: { [myId]: true, [dev]: true },
                    createdAt: Date.now()
                  });
                }
              });
              db.ref("users/" + myId + "/chats/" + cid).set({ name: from, type: "private", last: Date.now() });
              db.ref("users/" + myId + "/requests/" + from).remove();
              db.ref("users/" + myId + "/friends/" + from).set(true);
              db.ref("users/" + dev + "/friends/" + displayName).set(true);
              db.ref("users/" + dev + "/accepted/" + displayName).set(true);
              db.ref("privateChats/" + cid + "/messages").push({
                sender: "_system",
                text: `${from} accepted your friend request!`,
                timestamp: Date.now(),
                reaction: "",
                readBy: { [dev]: Date.now() }
              });
              openChat(cid, from, "private");
            });
          };
          di.appendChild(accept);
          let deny = document.createElement("button");
          deny.textContent = "âœ˜";
          deny.style.background = "red";
          deny.onclick = () => { db.ref("users/" + myId + "/requests/" + from).remove(); };
          di.appendChild(deny);
          tab.appendChild(di);
        });
      });
      db.ref("users/" + myId + "/requestsSent").on("value", snap => {
        let st = document.getElementById("requestsSentTab");
        st.innerHTML = "<strong>Requests Sent:</strong><br/>";
        let out = snap.val() || {};
        Object.keys(out).forEach(n => {
          let dv = document.createElement("div");
          dv.className = "requestItem";
          dv.textContent = `(Pending) ${n} `;
          let c = document.createElement("button");
          c.textContent = "Cancel";
          c.onclick = () => {
            db.ref("users/" + myId + "/requestsSent/" + n).remove();
            db.ref("displayNames/" + n).once("value", snap => {
              let dev = snap.val();
              if (dev) { db.ref("users/" + dev + "/requests/" + displayName).remove(); }
            });
          };
          dv.appendChild(c);
          st.appendChild(dv);
        });
      });
      db.ref("users/" + myId + "/accepted").on("child_added", snap => {
        let who = snap.key;
        showNotice(`${who} accepted your request!`);
        db.ref("users/" + myId + "/requestsSent/" + who).remove();
        db.ref("displayNames/" + who).once("value", snap => {
          let dev = snap.val();
          if (!dev) return;
          let cid = [myId, dev].sort().join("_");
          db.ref("privateChats/" + cid).once("value", snap2 => {
            if (!snap2.exists()) {
              db.ref("privateChats/" + cid).set({
                members: { [myId]: true, [dev]: true },
                createdAt: Date.now()
              });
            }
          });
          db.ref("users/" + myId + "/chats/" + cid).set({ name: who, type: "private", last: Date.now() });
        });
        setTimeout(() => { db.ref("users/" + myId + "/accepted/" + who).remove(); }, 3000);
      });
    }
    function loadBlocked() {
      db.ref("users/" + myId + "/blocked").on("value", snap => { blocked = snap.val() || {}; });
    }
    function loadFriends() {
      db.ref("users/" + myId + "/friends").on("value", snap => { friends = snap.val() || {}; });
    }
    function initChatWatchers() {
      db.ref("users/" + myId + "/chats").on("value", snap => {
        let chats = snap.val() || {};
        attachAllChatWatchers(chats);
        updateChatListUI(chats);
      });
    }
    function attachAllChatWatchers(chats) {
      Object.keys(chats).forEach(cid => {
        if (cid === "help_chat") return;
        let info = chats[cid];
        let path = (info.type === "group" ? "groupChats" : "privateChats") + "/" + cid + "/messages";
        db.ref(path).off("child_added", handleMsg);
        db.ref(path).on("child_added", handleMsg);
        function handleMsg(snap) {
          if (cid === currentChat) return;
          chatUnread[cid] = (chatUnread[cid] || 0) + 1;
          updateChatListUI(chats);
        }
      });
    }
    function updateChatListUI(chats) {
      let arr = Object.entries(chats).sort((a, b) => (b[1].last || 0) - (a[1].last || 0));
      let cl = document.getElementById("chatList");
      cl.innerHTML = "";
      arr.forEach(([cid, info]) => {
        let dv = document.createElement("div");
        dv.className = "chatItem";
        if (cid === currentChat) dv.classList.add("active");
        let nm = info.name || cid;
        if (info.type === "private" && blocked[nm]) nm += " [Blocked]";
        if (info.type === "help") nm = "Help (info)";
        dv.textContent = nm;
        let rowR = document.createElement("div");
        rowR.style.display = "flex";
        rowR.style.alignItems = "center";
        if (chatUnread[cid]) {
          let bd = document.createElement("span");
          bd.className = "chatBadge";
          bd.textContent = "+" + chatUnread[cid];
          rowR.appendChild(bd);
        }
        if (info.type !== "help") {
          let delBtn = document.createElement("button");
          delBtn.textContent = "ðŸ—‘";
          delBtn.onclick = ev => {
            ev.stopPropagation();
            confirmDeleteChat(cid, info);
          };
          rowR.appendChild(delBtn);
        }
        dv.appendChild(rowR);
        dv.onclick = () => {
          if (info.type === "help") { /* Help chat removed */ }
          else openChat(cid, nm, info.type);
        };
        cl.appendChild(dv);
      });
    }
    function confirmDeleteChat(cid, info) {
      if (info.type === "group") {
        db.ref("groupChats/" + cid + "/createdBy").once("value", snap => {
          let own = snap.val();
          if (own !== myId) {
            showConfirm("Leave group " + info.name + "?").then(ok => {
              if (ok) {
                db.ref("groupChats/" + cid + "/members/" + myId).remove();
                db.ref("users/" + myId + "/chats/" + cid).remove();
                showNotice("Left group chat successfully.");
              }
            });
          } else {
            showConfirm("Delete group " + info.name + "?").then(ok => {
              if (ok) {
                db.ref("groupChats/" + cid).remove();
                db.ref("users/" + myId + "/chats/" + cid).remove();
                showNotice("Group chat deleted for all members!");
              }
            });
          }
        });
      } else {
        showConfirm("Remove private chat with " + info.name + "?").then(ok => {
          if (ok) {
            db.ref("users/" + myId + "/chats/" + cid).remove();
            showNotice("Private chat removed from your side.");
          }
        });
      }
    }
    
    // ========== Chat Display & Message Loading ==========
    let messagesRef = null, childAddedRef = null, childChangedRef = null;
    let oldestStamp = Number.MAX_SAFE_INTEGER, hasMoreOld = false;
    let currentChat = "", currentType = "";
    function openChat(cid, name, type) {
      currentChat = cid;
      currentType = type;
      chatUnread[cid] = 0;
      updateChatListUI({});
      if (type === "group") {
        document.getElementById("chatTitle").innerHTML = `<div id="groupTitle">${name}</div><div>You: ${displayName}</div>`;
      } else {
        document.getElementById("chatTitle").textContent = name;
      }
      let gm = document.getElementById("groupMembers");
      gm.style.display = (type === "group") ? "block" : "none";
      let inp = document.getElementById("msgInput");
      inp.disabled = (type === "help");
      let msgArea = document.getElementById("messages");
      msgArea.innerHTML = "";
      document.getElementById("loadMoreBtn").style.display = "none";
      if (messagesRef) {
        if (childAddedRef) messagesRef.off("child_added", childAddedRef);
        if (childChangedRef) messagesRef.off("child_changed", childChangedRef);
      }
      let path = (type === "group" ? "groupChats" : "privateChats") + "/" + cid + "/messages";
      messagesRef = db.ref(path);
      messagesRef.orderByChild("timestamp").limitToLast(100).once("value", snap => {
        let data = snap.val() || {};
        let arr = Object.entries(data).sort((a, b) => (a[1].timestamp || 0) - (b[1].timestamp || 0));
        oldestStamp = arr.length > 0 ? arr[0][1].timestamp : Number.MAX_SAFE_INTEGER;
        arr.forEach(([mId, mVal]) => createBubble(mId, mVal, true));
        if (arr.length >= 100) {
          hasMoreOld = true;
          document.getElementById("loadMoreBtn").style.display = "block";
        } else {
          hasMoreOld = false;
        }
        childAddedRef = messagesRef.orderByChild("timestamp").startAt(Date.now()).on("child_added", snap => {
          let v = snap.val();
          createBubble(snap.key, v, true);
          autoScroll();
          markMsgRead(snap.key, v);
        });
        childChangedRef = messagesRef.on("child_changed", snap => updateBubble(snap.key, snap.val()));
        autoScroll();
        Object.entries(data).forEach(([mId, mVal]) => markMsgRead(mId, mVal));
      });
      if (type === "group") {
        db.ref("groupChats/" + cid + "/members").on("value", snap => {
          let members = Object.keys(snap.val() || {});
          gm.textContent = "Members: " + members.join(", ");
        });
      }
      attachTypingListener();
    }
    function markMsgRead(mId, val) {
      if (!currentChat || currentType === "help") return;
      let path = (currentType === "group" ? "groupChats" : "privateChats") + "/" + currentChat + "/messages/" + mId + "/readBy/" + myId;
      db.ref(path).set(Date.now());
    }
    function loadOlderMessages() {
      if (!currentChat || !hasMoreOld) return;
      let btn = document.getElementById("loadMoreBtn");
      btn.disabled = true;
      messagesRef.orderByChild("timestamp").endAt(oldestStamp - 1).limitToLast(50).once("value", snap => {
        let data = snap.val() || {};
        let arr = Object.entries(data).sort((a, b) => (a[1].timestamp || 0) - (b[1].timestamp || 0));
        if (arr.length < 1) {
          showNotice("No older messages found.");
          hasMoreOld = false;
          btn.style.display = "none";
          btn.disabled = false;
          return;
        }
        oldestStamp = arr[0][1].timestamp;
        arr.forEach(([mId, mVal]) => createBubble(mId, mVal, false));
        if (arr.length < 50) { hasMoreOld = false; btn.style.display = "none"; }
        arr.forEach(([mId, mVal]) => markMsgRead(mId, mVal));
        btn.disabled = false;
      });
    }
    function createBubble(mId, val, toEnd) {
      let area = document.getElementById("messages");
      if (document.getElementById("msg_" + mId)) return;
      let bubble = document.createElement("div");
      bubble.id = "msg_" + mId;
      bubble.className = "msg";
      if (val.sender === myId) bubble.classList.add("to");
      else if (val.sender === "_system") bubble.classList.add("console");
      else bubble.classList.add("from");
      // Add message text
      let p = document.createElement("p");
      p.textContent = val.text || "";
      bubble.appendChild(p);
      // Reaction tag
      let rt = document.createElement("span");
      rt.className = "reactionTag";
      if (val.reaction) rt.textContent = val.reaction;
      bubble.appendChild(rt);
      // Reaction bar
      let rBar = document.createElement("div");
      rBar.className = "reactionBar";
      ["â¤ï¸", "ðŸ‘", "ðŸ‘Ž", "ðŸ˜‚", "ðŸ˜®", "ðŸ˜¢"].forEach(emoji => {
        let span = document.createElement("span");
        span.textContent = emoji;
        span.onclick = ev => { ev.stopPropagation(); applyReaction(mId, emoji); rBar.style.display = "none"; };
        rBar.appendChild(span);
      });
      bubble.appendChild(rBar);
      bubble.addEventListener("dblclick", () => {
        rBar.style.display = (rBar.style.display === "flex") ? "none" : "flex";
      });
      // Delete button (if the message belongs to you or if you're group owner)
      if(val.sender === myId) {
        let delBtn = document.createElement("button");
        delBtn.textContent = "Delete";
        delBtn.style.position = "absolute";
        delBtn.style.bottom = "4px";
        delBtn.style.right = "4px";
        delBtn.style.fontSize = "12px";
        delBtn.onclick = e => {
          e.stopPropagation();
          showConfirm("Delete this message?").then(ok => {
            if (ok) {
              let path = (currentType === "group" ? "groupChats" : "privateChats") + "/" + currentChat + "/messages/" + mId;
              db.ref(path).remove();
              let el = document.getElementById("msg_" + mId);
              if(el) el.remove();
            }
          });
        };
        bubble.appendChild(delBtn);
      }
      // Timestamp
      let ts = document.createElement("div");
      ts.className = "timestamp";
      let t = val.timestamp ? new Date(val.timestamp).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }) : "";
      ts.textContent = t;
      bubble.appendChild(ts);
      if (toEnd) area.appendChild(bubble); else area.prepend(bubble);
      setTimeout(() => { autoScroll(); }, 50);
    }
    function updateBubble(mId, val) {
      let b = document.getElementById("msg_" + mId);
      if (!b) return;
      let rt = b.querySelector(".reactionTag");
      if (rt) rt.textContent = val.reaction || "";
    }
    function applyReaction(mId, emoji) {
      let path = (currentType === "group" ? "groupChats" : "privateChats") + "/" + currentChat + "/messages/" + mId + "/reaction";
      db.ref(path).set(emoji);
    }
    
    // ========== Typing & Emoji ==========
    function attachTypingListener() {
      if (!currentChat || currentType === "help") return;
      let path = (currentType === "group" ? "groupChats" : "privateChats") + "/" + currentChat + "/typing";
      db.ref(path).off();
      db.ref(path).on("value", snap => {
        let val = snap.val();
        let t = document.getElementById("typingIndicator");
        if (currentChat && val && val !== displayName) { t.style.display = "block"; t.textContent = val + " is typing..."; }
        else { t.style.display = "none"; }
      });
    }
    function sendTyping() {
      if (!currentChat || currentType === "help") return;
      let path = (currentType === "group" ? "groupChats" : "privateChats") + "/" + currentChat + "/typing";
      db.ref(path).set(displayName);
      setTimeout(() => db.ref(path).set(""), 2000);
    }
    function toggleEmojiPicker() {
      let ep = document.getElementById("emojiPicker");
      if (ep.style.display === "flex") { ep.style.display = "none"; return; }
      ep.innerHTML = "";
      ep.style.display = "flex";
      let emojis = [..."ðŸ˜€ðŸ˜ƒðŸ˜„ðŸ˜ðŸ˜†ðŸ˜…ðŸ˜‚ðŸ¤£ðŸ˜ŠðŸ˜‡ðŸ™‚ðŸ™ƒðŸ˜‰ðŸ˜ŒðŸ˜ðŸ˜˜ðŸ¥°ðŸ˜—ðŸ˜™ðŸ˜šðŸ˜‹ðŸ˜›ðŸ˜ðŸ˜œðŸ¤ªðŸ¤¨ðŸ§ðŸ¤“ðŸ˜ŽðŸ¥¸ðŸ¤©ðŸ¥³ðŸ˜ðŸ˜’ðŸ˜žðŸ˜”ðŸ˜ŸðŸ˜•ðŸ™â˜¹ï¸ðŸ˜£ðŸ˜–ðŸ˜«ðŸ˜©ðŸ¥ºðŸ˜¢ðŸ˜­ðŸ˜¤ðŸ˜ ðŸ˜¡ðŸ¤¬ðŸ¤¯ðŸ˜³ðŸ¥µðŸ¥¶ðŸ˜±ðŸ˜¨ðŸ˜°ðŸ˜¥ðŸ˜“ðŸ¤—ðŸ¤”"];
      emojis.forEach(e => {
        let span = document.createElement("span");
        span.textContent = e;
        span.onclick = () => { document.getElementById("msgInput").value += e; ep.style.display = "none"; };
        ep.appendChild(span);
      });
    }
    
    // ========== Slash Commands & Autocomplete ==========
    function slashAutoInput(e) {
      let val = e.target.value;
      let sc = document.getElementById("slashAutocomplete");
      if (!val.startsWith("/")) { sc.style.display = "none"; return; }
      sc.innerHTML = "";
      let rect = e.target.getBoundingClientRect();
      sc.style.left = rect.left + "px";
      sc.style.top = rect.top - 115 + "px";
      let hits = slashCmds.filter(c => c.startsWith(val));
      if (!hits.length) { sc.style.display = "none"; return; }
      hits.slice(0, 8).forEach(cmd => {
        let b = document.createElement("button");
        b.textContent = cmd;
        b.onclick = () => { e.target.value = cmd + " "; sc.style.display = "none"; };
        sc.appendChild(b);
      });
      sc.style.display = "block";
    }
    
    // ========== Client-Side Cooldown & Message Sending ==========
    function canSendMessage() {
      let nowTime = Date.now();
      if (nowTime - lastMessageTime < 500) {
        showNotice("Please wait 0.5 seconds between messages.");
        return false;
      }
      lastMessageTime = nowTime;
      return true;
    }
    function sendMessage() {
      if (!currentChat || currentType === "help") return;
      if (!canSendMessage()) return;
      let inp = document.getElementById("msgInput");
      let txt = inp.value.trim();
      if (!txt) return;
      document.getElementById("slashAutocomplete").style.display = "none";
      if (txt.startsWith("/")) {
        processSlashCommand(txt);
        inp.value = "";
        return;
      }
      let path = (currentType === "group" ? "groupChats" : "privateChats") + "/" + currentChat + "/messages";
      db.ref(path).push({
        sender: myId,
        text: txt,
        timestamp: Date.now(),
        reaction: "",
        readBy: { [myId]: Date.now() }
      });
      inp.value = "";
      setTimeout(() => { autoScroll(); }, 50);
      sendTyping();
    }
    
    // ========== Slash Command Processing ==========
    function processSlashCommand(cmd) {
      let parts = cmd.split(" ");
      let slash = parts[0].toLowerCase();
      if (slash === "/roll") {
        let sides = parseInt(parts[1], 10) || 6;
        let r = Math.floor(Math.random() * sides) + 1;
        sendSystemMessage("ðŸŽ² Rolled a " + sides + "-sided die: " + r);
      } else if (slash === "/ping") {
        let t0 = Date.now();
        db.ref("pingTest").set({ time: t0 }, () => {
          let dt = Date.now() - t0;
          sendSystemMessage("Ping: " + dt + "ms");
        });
      } else if (slash === "/8ball") {
        let q = cmd.slice(7).trim();
        if (!q) { showNotice("Usage: /8ball [question]"); return; }
        let answers = ["Yes", "No", "Maybe", "Ask again later", "Definitely", "Certainly not"];
        let pick = answers[Math.floor(Math.random() * answers.length)];
        sendSystemMessage("8ball: " + pick);
      } else if (slash === "/roast") {
        let roasts = [
          "Your code has more bugs than a beehive.",
          "You're slower than dial-up internet.",
          "At least your chat is entertaining."
        ];
        let pick = roasts[Math.floor(Math.random() * roasts.length)];
        sendSystemMessage("Roast: " + pick);
      } else if (slash === "/tod") {
        if (parts[1] === "truth") {
          let truths = [
            "What's your biggest fear?",
            "Have you ever lied to your best friend?",
            "What's your most embarrassing moment?"
          ];
          let pick = truths[Math.floor(Math.random() * truths.length)];
          sendSystemMessage("Truth: " + pick);
        } else if (parts[1] === "dare") {
          let dares = [
            "Dance like a robot for 15 seconds.",
            "Talk in a baby voice for 3 messages.",
            "Pretend you're an alien for 10 seconds."
          ];
          let pick = dares[Math.floor(Math.random() * dares.length)];
          sendSystemMessage("Dare: " + pick);
        } else { showNotice("Usage: /tod truth or /tod dare"); }
      } else if (slash === "/title") {
        let text = parts.slice(1).join(" ");
        if (!text) { showNotice("Usage: /title [text]"); return; }
        sendSystemMessage("<< " + text + " >>");
      } else if (slash === "/cf" || slash === "/coin") {
        let guess = "";
        if (slash === "/cf") guess = parts[1] || "";
        else if (parts[1] === "flip") guess = parts[2] || "";
        guess = guess.toLowerCase();
        if (guess !== "heads" && guess !== "tails") { showNotice("Usage: /cf heads or /coin flip tails"); return; }
        let side = Math.random() < 0.5 ? "heads" : "tails";
        sendSystemMessage("Coinflip: " + side + " => you chose " + guess + " => " + (side === guess ? "You win!" : "You lose."));
      } else if (slash === "/ship") {
        let n = parts[1] || "";
        if (!n) { showNotice("Usage: /ship [name]"); return; }
        let merged = displayName.slice(0, Math.floor(displayName.length / 2)) + n.slice(Math.floor(n.length / 2));
        sendSystemMessage("Ship: " + displayName + " + " + n + " => " + merged + " ðŸ’˜");
      } else if (slash === "/rps") {
        sendSystemMessage("[RPS] " + displayName + " played rock (placeholder)");
      } else if (slash === "/guessnumber") {
        sendSystemMessage("[GuessNumber] Waiting for opponent (placeholder)");
      } else if (slash === "/vote") {
        let rest = cmd.slice(slash.length).trim();
        let parts = rest.split("|").map(x => x.trim());
        if (parts.length < 2) { showNotice("Usage: /vote question|opt1|opt2"); return; }
        let out = "Vote: " + parts[0] + "\n";
        parts.slice(1).forEach(o => { out += "- " + o + "\n"; });
        sendSystemMessage(out);
      } else {
        showNotice("Unknown slash command: " + cmd);
      }
    }
    function sendSystemMessage(text) {
      if (!currentChat || currentType === "help") return;
      let path = (currentType === "group" ? "groupChats" : "privateChats") + "/" + currentChat + "/messages";
      db.ref(path).push({
        sender: "_system",
        text: text,
        timestamp: Date.now(),
        reaction: "",
        readBy: { [myId]: Date.now() }
      });
    }
    
    // ========== Friend Request & Chat Watchers ==========
    function loadRequests() {
      db.ref("users/" + myId + "/requests").on("value", snap => {
        let data = snap.val() || {};
        let tab = document.getElementById("requestsTab");
        tab.innerHTML = "";
        Object.keys(data).forEach(from => {
          let di = document.createElement("div");
          di.className = "requestItem";
          di.textContent = `${from} wants to chat. `;
          let accept = document.createElement("button");
          accept.textContent = "âœ”";
          accept.style.background = "green";
          accept.onclick = () => {
            if (blocked[from]) { showNotice("Unblock them first!"); return; }
            db.ref("displayNames/" + from).once("value", snap => {
              let dev = snap.val();
              if (!dev) { showNotice("User not found!"); return; }
              let cid = [myId, dev].sort().join("_");
              db.ref("privateChats/" + cid).once("value", snap2 => {
                if (!snap2.exists()) {
                  db.ref("privateChats/" + cid).set({
                    members: { [myId]: true, [dev]: true },
                    createdAt: Date.now()
                  });
                }
              });
              db.ref("users/" + myId + "/chats/" + cid).set({ name: from, type: "private", last: Date.now() });
              db.ref("users/" + myId + "/requests/" + from).remove();
              db.ref("users/" + myId + "/friends/" + from).set(true);
              db.ref("users/" + dev + "/friends/" + displayName).set(true);
              db.ref("users/" + dev + "/accepted/" + displayName).set(true);
              db.ref("privateChats/" + cid + "/messages").push({
                sender: "_system",
                text: `${from} accepted your friend request!`,
                timestamp: Date.now(),
                reaction: "",
                readBy: { [dev]: Date.now() }
              });
              openChat(cid, from, "private");
            });
          };
          di.appendChild(accept);
          let deny = document.createElement("button");
          deny.textContent = "âœ˜";
          deny.style.background = "red";
          deny.onclick = () => { db.ref("users/" + myId + "/requests/" + from).remove(); };
          di.appendChild(deny);
          tab.appendChild(di);
        });
      });
      db.ref("users/" + myId + "/requestsSent").on("value", snap => {
        let st = document.getElementById("requestsSentTab");
        st.innerHTML = "<strong>Requests Sent:</strong><br/>";
        let out = snap.val() || {};
        Object.keys(out).forEach(n => {
          let dv = document.createElement("div");
          dv.className = "requestItem";
          dv.textContent = `(Pending) ${n} `;
          let btn = document.createElement("button");
          btn.textContent = "Cancel";
          btn.onclick = () => {
            db.ref("users/" + myId + "/requestsSent/" + n).remove();
            db.ref("displayNames/" + n).once("value", snap => {
              let dev = snap.val();
              if (dev) { db.ref("users/" + dev + "/requests/" + displayName).remove(); }
            });
          };
          dv.appendChild(btn);
          st.appendChild(dv);
        });
      });
      db.ref("users/" + myId + "/accepted").on("child_added", snap => {
        let who = snap.key;
        showNotice(`${who} accepted your request!`);
        db.ref("users/" + myId + "/requestsSent/" + who).remove();
        db.ref("displayNames/" + who).once("value", snap => {
          let dev = snap.val();
          if (!dev) return;
          let cid = [myId, dev].sort().join("_");
          db.ref("privateChats/" + cid).once("value", snap2 => {
            if (!snap2.exists()) {
              db.ref("privateChats/" + cid).set({
                members: { [myId]: true, [dev]: true },
                createdAt: Date.now()
              });
            }
          });
          db.ref("users/" + myId + "/chats/" + cid).set({ name: who, type: "private", last: Date.now() });
        });
        setTimeout(() => { db.ref("users/" + myId + "/accepted/" + who).remove(); }, 3000);
      });
    }
    function loadBlocked() {
      db.ref("users/" + myId + "/blocked").on("value", snap => { blocked = snap.val() || {}; });
    }
    function loadFriends() {
      db.ref("users/" + myId + "/friends").on("value", snap => { friends = snap.val() || {}; });
    }
    function initChatWatchers() {
      db.ref("users/" + myId + "/chats").on("value", snap => {
        let chats = snap.val() || {};
        attachAllChatWatchers(chats);
        updateChatListUI(chats);
      });
    }
    function attachAllChatWatchers(chats) {
      Object.keys(chats).forEach(cid => {
        if (cid === "help_chat") return;
        let info = chats[cid];
        let path = (info.type === "group" ? "groupChats" : "privateChats") + "/" + cid + "/messages";
        db.ref(path).off("child_added", handleMsg);
        db.ref(path).on("child_added", handleMsg);
        function handleMsg(snap) {
          if (cid === currentChat) return;
          chatUnread[cid] = (chatUnread[cid] || 0) + 1;
          updateChatListUI(chats);
        }
      });
    }
    function updateChatListUI(chats) {
      let arr = Object.entries(chats).sort((a, b) => (b[1].last || 0) - (a[1].last || 0));
      let cl = document.getElementById("chatList");
      cl.innerHTML = "";
      arr.forEach(([cid, info]) => {
        let dv = document.createElement("div");
        dv.className = "chatItem";
        if (cid === currentChat) dv.classList.add("active");
        let nm = info.name || cid;
        if (info.type === "private" && blocked[nm]) nm += " [Blocked]";
        if (info.type === "help") nm = "Help (info)";
        dv.textContent = nm;
        let right = document.createElement("div");
        right.style.display = "flex";
        right.style.alignItems = "center";
        if (chatUnread[cid]) {
          let badge = document.createElement("span");
          badge.className = "chatBadge";
          badge.textContent = "+" + chatUnread[cid];
          right.appendChild(badge);
        }
        if (info.type !== "help") {
          let dots = document.createElement("span");
          dots.textContent = "â‹®";
          dots.style.cursor = "pointer";
          dots.style.position = "relative";
          let menu = document.createElement("div");
          menu.className = "friendMenu";
          menu.style.left = "calc(100% + 5px)";
          menu.style.top = "0px";
          let openBtn = document.createElement("button");
          openBtn.textContent = "Open Chat";
          openBtn.onclick = () => {
            db.ref("displayNames/" + nm).once("value", snap => {
              let dev = snap.val();
              if (!dev) { showNotice("User not found!"); return; }
              let cid = [myId, dev].sort().join("_");
              db.ref("privateChats/" + cid).once("value", snap2 => {
                if (!snap2.exists()) {
                  db.ref("privateChats/" + cid).set({
                    members: { [myId]: true, [dev]: true },
                    createdAt: Date.now()
                  });
                }
              });
              db.ref("users/" + myId + "/chats/" + cid).set({ name: nm, type: "private", last: Date.now() });
              openChat(cid, nm, "private");
            });
            menu.style.display = "none";
          };
          menu.appendChild(openBtn);
          let unfriendBtn = document.createElement("button");
          unfriendBtn.textContent = "Unfriend";
          unfriendBtn.onclick = () => {
            showConfirm("Unfriend " + nm + "?").then(ok => {
              if (ok) {
                db.ref("users/" + myId + "/friends/" + nm).remove();
                db.ref("displayNames/" + nm).once("value", snap => {
                  let dev = snap.val();
                  if (dev) { db.ref("users/" + dev + "/friends/" + displayName).remove(); }
                });
                showNotice("Unfriended " + nm);
              }
            });
            menu.style.display = "none";
          };
          menu.appendChild(unfriendBtn);
          let blockBtn = document.createElement("button");
          blockBtn.textContent = "Block";
          blockBtn.onclick = () => {
            showConfirm("Block " + nm + "?").then(ok => {
              if (ok) { db.ref("users/" + myId + "/blocked/" + nm).set(true); showNotice("Blocked " + nm); }
            });
            menu.style.display = "none";
          };
          menu.appendChild(blockBtn);
          dots.onclick = ev => {
            ev.stopPropagation();
            menu.style.display = (menu.style.display === "flex") ? "none" : "flex";
          };
          right.appendChild(dots);
          right.appendChild(menu);
        }
        dv.appendChild(right);
        dv.onclick = () => {
          if (info.type === "help") { /* Help chat removed */ }
          else openChat(cid, nm, info.type);
        };
        cl.appendChild(dv);
      });
    }
    
    // ========== Chat Display & Message Loading ==========
    let messagesRef = null, childAddedRef = null, childChangedRef = null;
    let oldestStamp = Number.MAX_SAFE_INTEGER, hasMoreOld = false;
    let currentChat = "", currentType = "";
    function openChat(cid, name, type) {
      currentChat = cid;
      currentType = type;
      chatUnread[cid] = 0;
      updateChatListUI({});
      if (type === "group") {
        document.getElementById("chatTitle").innerHTML = `<div id="groupTitle">${name}</div><div>You: ${displayName}</div>`;
      } else {
        document.getElementById("chatTitle").textContent = name;
      }
      let gm = document.getElementById("groupMembers");
      gm.style.display = (type === "group") ? "block" : "none";
      let inp = document.getElementById("msgInput");
      inp.disabled = (type === "help");
      let area = document.getElementById("messages");
      area.innerHTML = "";
      document.getElementById("loadMoreBtn").style.display = "none";
      if (messagesRef) {
        if (childAddedRef) messagesRef.off("child_added", childAddedRef);
        if (childChangedRef) messagesRef.off("child_changed", childChangedRef);
      }
      let path = (type === "group" ? "groupChats" : "privateChats") + "/" + cid + "/messages";
      messagesRef = db.ref(path);
      messagesRef.orderByChild("timestamp").limitToLast(100).once("value", snap => {
        let data = snap.val() || {};
        let arr = Object.entries(data).sort((a, b) => (a[1].timestamp || 0) - (b[1].timestamp || 0));
        oldestStamp = arr.length > 0 ? arr[0][1].timestamp : Number.MAX_SAFE_INTEGER;
        arr.forEach(([mId, mVal]) => { createBubble(mId, mVal, true); });
        if (arr.length >= 100) {
          hasMoreOld = true;
          document.getElementById("loadMoreBtn").style.display = "block";
        } else {
          hasMoreOld = false;
        }
        childAddedRef = messagesRef.orderByChild("timestamp").startAt(Date.now()).on("child_added", snap => {
          let v = snap.val();
          createBubble(snap.key, v, true);
          autoScroll();
          markMsgRead(snap.key, v);
        });
        childChangedRef = messagesRef.on("child_changed", snap => updateBubble(snap.key, snap.val()));
        autoScroll();
        Object.entries(data).forEach(([mId, mVal]) => markMsgRead(mId, mVal));
      });
      if (type === "group") {
        db.ref("groupChats/" + cid + "/members").on("value", snap => {
          let members = Object.keys(snap.val() || {});
          gm.textContent = "Members: " + members.join(", ");
        });
      }
      attachTypingListener();
    }
    function markMsgRead(mId, val) {
      if (!currentChat || currentType === "help") return;
      let path = (currentType === "group" ? "groupChats" : "privateChats") + "/" + currentChat + "/messages/" + mId + "/readBy/" + myId;
      db.ref(path).set(Date.now());
    }
    function loadOlderMessages() {
      if (!currentChat || !hasMoreOld) return;
      let btn = document.getElementById("loadMoreBtn");
      btn.disabled = true;
      messagesRef.orderByChild("timestamp").endAt(oldestStamp - 1).limitToLast(50).once("value", snap => {
        let data = snap.val() || {};
        let arr = Object.entries(data).sort((a, b) => (a[1].timestamp || 0) - (b[1].timestamp || 0));
        if (arr.length < 1) {
          showNotice("No older messages found!");
          hasMoreOld = false;
          btn.style.display = "none";
          btn.disabled = false;
          return;
        }
        oldestStamp = arr[0][1].timestamp;
        arr.forEach(([mId, mVal]) => createBubble(mId, mVal, false));
        if (arr.length < 50) { hasMoreOld = false; btn.style.display = "none"; }
        arr.forEach(([mId, mVal]) => markMsgRead(mId, mVal));
        btn.disabled = false;
      });
    }
    
    // ========== Create/Update Message Bubble ==========
    function createBubble(mId, val, toEnd) {
      let area = document.getElementById("messages");
      if (document.getElementById("msg_" + mId)) return;
      let bubble = document.createElement("div");
      bubble.id = "msg_" + mId;
      bubble.className = "msg";
      if (val.sender === myId) bubble.classList.add("to");
      else if (val.sender === "_system") bubble.classList.add("console");
      else bubble.classList.add("from");
      let p = document.createElement("p");
      p.textContent = val.text || "";
      bubble.appendChild(p);
      let rt = document.createElement("span");
      rt.className = "reactionTag";
      if (val.reaction) rt.textContent = val.reaction;
      bubble.appendChild(rt);
      let rBar = document.createElement("div");
      rBar.className = "reactionBar";
      ["â¤ï¸", "ðŸ‘", "ðŸ‘Ž", "ðŸ˜‚", "ðŸ˜®", "ðŸ˜¢"].forEach(emoji => {
        let span = document.createElement("span");
        span.textContent = emoji;
        span.onclick = ev => { ev.stopPropagation(); applyReaction(mId, emoji); rBar.style.display = "none"; };
        rBar.appendChild(span);
      });
      bubble.appendChild(rBar);
      bubble.addEventListener("dblclick", () => {
        rBar.style.display = (rBar.style.display === "flex") ? "none" : "flex";
      });
      // Delete button: visible if you are the sender (or group owner)
      if(val.sender === myId){
        let delBtn = document.createElement("button");
        delBtn.textContent = "Delete";
        delBtn.style.position = "absolute";
        delBtn.style.bottom = "4px";
        delBtn.style.right = "4px";
        delBtn.style.fontSize = "12px";
        delBtn.onclick = e => {
          e.stopPropagation();
          showConfirm("Delete this message?").then(ok => {
            if (ok) {
              let path = (currentType === "group" ? "groupChats" : "privateChats") + "/" + currentChat + "/messages/" + mId;
              db.ref(path).remove();
              let el = document.getElementById("msg_" + mId);
              if(el) el.remove();
            }
          });
        };
        bubble.appendChild(delBtn);
      }
      let ts = document.createElement("div");
      ts.className = "timestamp";
      let t = val.timestamp ? new Date(val.timestamp).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }) : "";
      ts.textContent = t;
      bubble.appendChild(ts);
      if (toEnd) area.appendChild(bubble); else area.prepend(bubble);
      setTimeout(() => { autoScroll(); }, 50);
    }
    function updateBubble(mId, val) {
      let b = document.getElementById("msg_" + mId);
      if (!b) return;
      let rt = b.querySelector(".reactionTag");
      if (rt) rt.textContent = val.reaction || "";
    }
    function applyReaction(mId, emoji) {
      let path = (currentType === "group" ? "groupChats" : "privateChats") + "/" + currentChat + "/messages/" + mId + "/reaction";
      db.ref(path).set(emoji);
    }
    
    // ========== Typing & Emoji ==========
    function attachTypingListener() {
      if (!currentChat || currentType === "help") return;
      let path = (currentType === "group" ? "groupChats" : "privateChats") + "/" + currentChat + "/typing";
      db.ref(path).off();
      db.ref(path).on("value", snap => {
        let val = snap.val();
        let t = document.getElementById("typingIndicator");
        if (currentChat && val && val !== displayName) { t.style.display = "block"; t.textContent = val + " is typing..."; }
        else { t.style.display = "none"; }
      });
    }
    function sendTyping() {
      if (!currentChat || currentType === "help") return;
      let path = (currentType === "group" ? "groupChats" : "privateChats") + "/" + currentChat + "/typing";
      db.ref(path).set(displayName);
      setTimeout(() => db.ref(path).set(""), 2000);
    }
    function toggleEmojiPicker() {
      let ep = document.getElementById("emojiPicker");
      if (ep.style.display === "flex") { ep.style.display = "none"; return; }
      ep.innerHTML = "";
      ep.style.display = "flex";
      let emojis = [..."ðŸ˜€ðŸ˜ƒðŸ˜„ðŸ˜ðŸ˜†ðŸ˜…ðŸ˜‚ðŸ¤£ðŸ˜ŠðŸ˜‡ðŸ™‚ðŸ™ƒðŸ˜‰ðŸ˜ŒðŸ˜ðŸ˜˜ðŸ¥°ðŸ˜—ðŸ˜™ðŸ˜šðŸ˜‹ðŸ˜›ðŸ˜ðŸ˜œðŸ¤ªðŸ¤¨ðŸ§ðŸ¤“ðŸ˜ŽðŸ¥¸ðŸ¤©ðŸ¥³ðŸ˜ðŸ˜’ðŸ˜žðŸ˜”ðŸ˜ŸðŸ˜•ðŸ™â˜¹ï¸ðŸ˜£ðŸ˜–ðŸ˜«ðŸ˜©ðŸ¥ºðŸ˜¢ðŸ˜­ðŸ˜¤ðŸ˜ ðŸ˜¡ðŸ¤¬ðŸ¤¯ðŸ˜³ðŸ¥µðŸ¥¶ðŸ˜±ðŸ˜¨ðŸ˜°ðŸ˜¥ðŸ˜“ðŸ¤—ðŸ¤”"];
      emojis.forEach(e => {
        let span = document.createElement("span");
        span.textContent = e;
        span.onclick = () => { document.getElementById("msgInput").value += e; ep.style.display = "none"; };
        ep.appendChild(span);
      });
    }
    
    // ========== Slash Commands & Autocomplete ==========
    function slashAutoInput(e) {
      let val = e.target.value;
      let sc = document.getElementById("slashAutocomplete");
      if (!val.startsWith("/")) { sc.style.display = "none"; return; }
      sc.innerHTML = "";
      let rect = e.target.getBoundingClientRect();
      sc.style.left = rect.left + "px";
      sc.style.top = rect.top - 115 + "px";
      let hits = slashCmds.filter(c => c.startsWith(val));
      if (!hits.length) { sc.style.display = "none"; return; }
      hits.slice(0, 8).forEach(cmd => {
        let b = document.createElement("button");
        b.textContent = cmd;
        b.onclick = () => { e.target.value = cmd + " "; sc.style.display = "none"; };
        sc.appendChild(b);
      });
      sc.style.display = "block";
    }
    
    // ========== Client-Side Cooldown & Message Sending ==========
    function canSendMessage() {
      let nowTime = Date.now();
      if (nowTime - lastMessageTime < 500) {
        showNotice("Please wait 0.5 seconds between messages.");
        return false;
      }
      lastMessageTime = nowTime;
      return true;
    }
    function sendMessage() {
      if (!currentChat || currentType === "help") return;
      if (!canSendMessage()) return;
      let inp = document.getElementById("msgInput");
      let txt = inp.value.trim();
      if (!txt) return;
      document.getElementById("slashAutocomplete").style.display = "none";
      if (txt.startsWith("/")) {
        processSlashCommand(txt);
        inp.value = "";
        return;
      }
      let path = (currentType === "group" ? "groupChats" : "privateChats") + "/" + currentChat + "/messages";
      db.ref(path).push({
        sender: myId,
        text: txt,
        timestamp: Date.now(),
        reaction: "",
        readBy: { [myId]: Date.now() }
      });
      inp.value = "";
      setTimeout(() => { autoScroll(); }, 50);
      sendTyping();
    }
    
    // ========== Slash Command Processing ==========
    function processSlashCommand(cmd) {
      let parts = cmd.split(" ");
      let slash = parts[0].toLowerCase();
      if (slash === "/roll") {
        let sides = parseInt(parts[1], 10) || 6;
        let r = Math.floor(Math.random() * sides) + 1;
        sendSystemMessage("ðŸŽ² Rolled a " + sides + "-sided die: " + r);
      } else if (slash === "/ping") {
        let t0 = Date.now();
        db.ref("pingTest").set({ time: t0 }, () => {
          let dt = Date.now() - t0;
          sendSystemMessage("Ping: " + dt + "ms");
        });
      } else if (slash === "/8ball") {
        let q = cmd.slice(7).trim();
        if (!q) { showNotice("Usage: /8ball [question]"); return; }
        let answers = ["Yes", "No", "Maybe", "Ask again later", "Definitely", "Certainly not"];
        let pick = answers[Math.floor(Math.random() * answers.length)];
        sendSystemMessage("8ball: " + pick);
      } else if (slash === "/roast") {
        let roasts = [
          "Your code has more bugs than a beehive.",
          "You're slower than dial-up internet.",
          "At least your chat is entertaining."
        ];
        let pick = roasts[Math.floor(Math.random() * roasts.length)];
        sendSystemMessage("Roast: " + pick);
      } else if (slash === "/tod") {
        if (parts[1] === "truth") {
          let truths = [
            "What's your biggest fear?",
            "Have you ever lied to your best friend?",
            "What's your most embarrassing moment?"
          ];
          let pick = truths[Math.floor(Math.random() * truths.length)];
          sendSystemMessage("Truth: " + pick);
        } else if (parts[1] === "dare") {
          let dares = [
            "Dance like a robot for 15 seconds.",
            "Talk in a baby voice for 3 messages.",
            "Pretend you're an alien for 10 seconds."
          ];
          let pick = dares[Math.floor(Math.random() * dares.length)];
          sendSystemMessage("Dare: " + pick);
        } else { showNotice("Usage: /tod truth or /tod dare"); }
      } else if (slash === "/title") {
        let text = parts.slice(1).join(" ");
        if (!text) { showNotice("Usage: /title [text]"); return; }
        sendSystemMessage("<< " + text + " >>");
      } else if (slash === "/cf" || slash === "/coin") {
        let guess = "";
        if (slash === "/cf") guess = parts[1] || "";
        else if (parts[1] === "flip") guess = parts[2] || "";
        guess = guess.toLowerCase();
        if (guess !== "heads" && guess !== "tails") { showNotice("Usage: /cf heads or /coin flip tails"); return; }
        let side = Math.random() < 0.5 ? "heads" : "tails";
        sendSystemMessage("Coinflip: " + side + " => you chose " + guess + " => " + (side === guess ? "You win!" : "You lose."));
      } else if (slash === "/ship") {
        let n = parts[1] || "";
        if (!n) { showNotice("Usage: /ship [name]"); return; }
        let merged = displayName.slice(0, Math.floor(displayName.length / 2)) + n.slice(Math.floor(n.length / 2));
        sendSystemMessage("Ship: " + displayName + " + " + n + " => " + merged + " ðŸ’˜");
      } else if (slash === "/rps") {
        sendSystemMessage("[RPS] " + displayName + " played rock (placeholder)");
      } else if (slash === "/guessnumber") {
        sendSystemMessage("[GuessNumber] Waiting for opponent (placeholder)");
      } else if (slash === "/vote") {
        let rest = cmd.slice(slash.length).trim();
        let parts = rest.split("|").map(x => x.trim());
        if (parts.length < 2) { showNotice("Usage: /vote question|opt1|opt2"); return; }
        let out = "Vote: " + parts[0] + "\n";
        parts.slice(1).forEach(o => { out += "- " + o + "\n"; });
        sendSystemMessage(out);
      } else {
        showNotice("Unknown slash command: " + cmd);
      }
    }
    function sendSystemMessage(text) {
      if (!currentChat || currentType === "help") return;
      let path = (currentType === "group" ? "groupChats" : "privateChats") + "/" + currentChat + "/messages";
      db.ref(path).push({
        sender: "_system",
        text: text,
        timestamp: Date.now(),
        reaction: "",
        readBy: { [myId]: Date.now() }
      });
    }
    
    // ========== Friend Request & Chat Watchers ==========
    function loadRequests() {
      db.ref("users/" + myId + "/requests").on("value", snap => {
        let data = snap.val() || {};
        let tab = document.getElementById("requestsTab");
        tab.innerHTML = "";
        Object.keys(data).forEach(from => {
          let di = document.createElement("div");
          di.className = "requestItem";
          di.textContent = `${from} wants to chat. `;
          let accept = document.createElement("button");
          accept.textContent = "âœ”";
          accept.style.background = "green";
          accept.onclick = () => {
            if (blocked[from]) { showNotice("Unblock them first!"); return; }
            db.ref("displayNames/" + from).once("value", snap => {
              let dev = snap.val();
              if (!dev) { showNotice("User not found!"); return; }
              let cid = [myId, dev].sort().join("_");
              db.ref("privateChats/" + cid).once("value", snap2 => {
                if (!snap2.exists()) {
                  db.ref("privateChats/" + cid).set({
                    members: { [myId]: true, [dev]: true },
                    createdAt: Date.now()
                  });
                }
              });
              db.ref("users/" + myId + "/chats/" + cid).set({ name: from, type: "private", last: Date.now() });
              db.ref("users/" + myId + "/requests/" + from).remove();
              db.ref("users/" + myId + "/friends/" + from).set(true);
              db.ref("users/" + dev + "/friends/" + displayName).set(true);
              db.ref("users/" + dev + "/accepted/" + displayName).set(true);
              db.ref("privateChats/" + cid + "/messages").push({
                sender: "_system",
                text: `${from} accepted your friend request!`,
                timestamp: Date.now(),
                reaction: "",
                readBy: { [dev]: Date.now() }
              });
              openChat(cid, from, "private");
            });
          };
          di.appendChild(accept);
          let deny = document.createElement("button");
          deny.textContent = "âœ˜";
          deny.style.background = "red";
          deny.onclick = () => { db.ref("users/" + myId + "/requests/" + from).remove(); };
          di.appendChild(deny);
          tab.appendChild(di);
        });
      });
      db.ref("users/" + myId + "/requestsSent").on("value", snap => {
        let st = document.getElementById("requestsSentTab");
        st.innerHTML = "<strong>Requests Sent:</strong><br/>";
        let out = snap.val() || {};
        Object.keys(out).forEach(n => {
          let dv = document.createElement("div");
          dv.className = "requestItem";
          dv.textContent = `(Pending) ${n} `;
          let btn = document.createElement("button");
          btn.textContent = "Cancel";
          btn.onclick = () => {
            db.ref("users/" + myId + "/requestsSent/" + n).remove();
            db.ref("displayNames/" + n).once("value", snap => {
              let dev = snap.val();
              if (dev) { db.ref("users/" + dev + "/requests/" + displayName).remove(); }
            });
          };
          dv.appendChild(btn);
          st.appendChild(dv);
        });
      });
      db.ref("users/" + myId + "/accepted").on("child_added", snap => {
        let who = snap.key;
        showNotice(`${who} accepted your request!`);
        db.ref("users/" + myId + "/requestsSent/" + who).remove();
        db.ref("displayNames/" + who).once("value", snap => {
          let dev = snap.val();
          if (!dev) return;
          let cid = [myId, dev].sort().join("_");
          db.ref("privateChats/" + cid).once("value", snap2 => {
            if (!snap2.exists()) {
              db.ref("privateChats/" + cid).set({
                members: { [myId]: true, [dev]: true },
                createdAt: Date.now()
              });
            }
          });
          db.ref("users/" + myId + "/chats/" + cid).set({ name: who, type: "private", last: Date.now() });
        });
        setTimeout(() => { db.ref("users/" + myId + "/accepted/" + who).remove(); }, 3000);
      });
    }
    function loadBlocked() {
      db.ref("users/" + myId + "/blocked").on("value", snap => { blocked = snap.val() || {}; });
    }
    function loadFriends() {
      db.ref("users/" + myId + "/friends").on("value", snap => { friends = snap.val() || {}; });
    }
    function initChatWatchers() {
      db.ref("users/" + myId + "/chats").on("value", snap => {
        let chats = snap.val() || {};
        attachAllChatWatchers(chats);
        updateChatListUI(chats);
      });
    }
    function attachAllChatWatchers(chats) {
      Object.keys(chats).forEach(cid => {
        if (cid === "help_chat") return;
        let info = chats[cid];
        let path = (info.type === "group" ? "groupChats" : "privateChats") + "/" + cid + "/messages";
        db.ref(path).off("child_added", handleMsg);
        db.ref(path).on("child_added", handleMsg);
        function handleMsg(snap) {
          if (cid === currentChat) return;
          chatUnread[cid] = (chatUnread[cid] || 0) + 1;
          updateChatListUI(chats);
        }
      });
    }
    function updateChatListUI(chats) {
      let arr = Object.entries(chats).sort((a, b) => (b[1].last || 0) - (a[1].last || 0));
      let cl = document.getElementById("chatList");
      cl.innerHTML = "";
      arr.forEach(([cid, info]) => {
        let dv = document.createElement("div");
        dv.className = "chatItem";
        if (cid === currentChat) dv.classList.add("active");
        let nm = info.name || cid;
        if (info.type === "private" && blocked[nm]) nm += " [Blocked]";
        if (info.type === "help") nm = "Help (info)";
        dv.textContent = nm;
        let right = document.createElement("div");
        right.style.display = "flex";
        right.style.alignItems = "center";
        if (chatUnread[cid]) {
          let badge = document.createElement("span");
          badge.className = "chatBadge";
          badge.textContent = "+" + chatUnread[cid];
          right.appendChild(badge);
        }
        if (info.type !== "help") {
          let dots = document.createElement("span");
          dots.textContent = "â‹®";
          dots.style.cursor = "pointer";
          dots.style.position = "relative";
          let menu = document.createElement("div");
          menu.className = "friendMenu";
          menu.style.left = "calc(100% + 5px)";
          menu.style.top = "0px";
          let openBtn = document.createElement("button");
          openBtn.textContent = "Open Chat";
          openBtn.onclick = () => {
            db.ref("displayNames/" + nm).once("value", snap => {
              let dev = snap.val();
              if (!dev) { showNotice("User not found!"); return; }
              let cid = [myId, dev].sort().join("_");
              db.ref("privateChats/" + cid).once("value", snap2 => {
                if (!snap2.exists()) {
                  db.ref("privateChats/" + cid).set({
                    members: { [myId]: true, [dev]: true },
                    createdAt: Date.now()
                  });
                }
              });
              db.ref("users/" + myId + "/chats/" + cid).set({ name: nm, type: "private", last: Date.now() });
              openChat(cid, nm, "private");
            });
            menu.style.display = "none";
          };
          menu.appendChild(openBtn);
          let unfriendBtn = document.createElement("button");
          unfriendBtn.textContent = "Unfriend";
          unfriendBtn.onclick = () => {
            showConfirm("Unfriend " + nm + "?").then(ok => {
              if (ok) {
                db.ref("users/" + myId + "/friends/" + nm).remove();
                db.ref("displayNames/" + nm).once("value", snap => {
                  let dev = snap.val();
                  if (dev) { db.ref("users/" + dev + "/friends/" + displayName).remove(); }
                });
                showNotice("Unfriended " + nm);
              }
            });
            menu.style.display = "none";
          };
          menu.appendChild(unfriendBtn);
          let blockBtn = document.createElement("button");
          blockBtn.textContent = "Block";
          blockBtn.onclick = () => {
            showConfirm("Block " + nm + "?").then(ok => {
              if (ok) { db.ref("users/" + myId + "/blocked/" + nm).set(true); showNotice("Blocked " + nm); }
            });
            menu.style.display = "none";
          };
          menu.appendChild(blockBtn);
          dots.onclick = ev => {
            ev.stopPropagation();
            menu.style.display = (menu.style.display === "flex") ? "none" : "flex";
          };
          right.appendChild(dots);
          right.appendChild(menu);
        }
        dv.appendChild(right);
        dv.onclick = () => {
          if (info.type === "help") { /* Help chat removed */ }
          else openChat(cid, nm, info.type);
        };
        cl.appendChild(dv);
      });
    }
    
    // ========== Chat Display & Message Loading ==========
    let messagesRef = null, childAddedRef = null, childChangedRef = null;
    let oldestStamp = Number.MAX_SAFE_INTEGER, hasMoreOld = false;
    let currentChat = "", currentType = "";
    function openChat(cid, name, type) {
      currentChat = cid;
      currentType = type;
      chatUnread[cid] = 0;
      updateChatListUI({});
      if (type === "group") {
        document.getElementById("chatTitle").innerHTML = `<div id="groupTitle">${name}</div><div>You: ${displayName}</div>`;
      } else {
        document.getElementById("chatTitle").textContent = name;
      }
      let gm = document.getElementById("groupMembers");
      gm.style.display = (type === "group") ? "block" : "none";
      let inp = document.getElementById("msgInput");
      inp.disabled = (type === "help");
      let area = document.getElementById("messages");
      area.innerHTML = "";
      document.getElementById("loadMoreBtn").style.display = "none";
      if (messagesRef) {
        if (childAddedRef) messagesRef.off("child_added", childAddedRef);
        if (childChangedRef) messagesRef.off("child_changed", childChangedRef);
      }
      let path = (type === "group" ? "groupChats" : "privateChats") + "/" + cid + "/messages";
      messagesRef = db.ref(path);
      messagesRef.orderByChild("timestamp").limitToLast(100).once("value", snap => {
        let data = snap.val() || {};
        let arr = Object.entries(data).sort((a, b) => (a[1].timestamp || 0) - (b[1].timestamp || 0));
        oldestStamp = arr.length > 0 ? arr[0][1].timestamp : Number.MAX_SAFE_INTEGER;
        arr.forEach(([mId, mVal]) => createBubble(mId, mVal, true));
        if (arr.length >= 100) {
          hasMoreOld = true;
          document.getElementById("loadMoreBtn").style.display = "block";
        } else {
          hasMoreOld = false;
        }
        childAddedRef = messagesRef.orderByChild("timestamp").startAt(Date.now()).on("child_added", snap => {
          let v = snap.val();
          createBubble(snap.key, v, true);
          autoScroll();
          markMsgRead(snap.key, v);
        });
        childChangedRef = messagesRef.on("child_changed", snap => updateBubble(snap.key, snap.val()));
        autoScroll();
        Object.entries(data).forEach(([mId, mVal]) => markMsgRead(mId, mVal));
      });
      if (type === "group") {
        db.ref("groupChats/" + cid + "/members").on("value", snap => {
          let members = Object.keys(snap.val() || {});
          gm.textContent = "Members: " + members.join(", ");
        });
      }
      attachTypingListener();
    }
    function markMsgRead(mId, val) {
      if (!currentChat || currentType === "help") return;
      let path = (currentType === "group" ? "groupChats" : "privateChats") + "/" + currentChat + "/messages/" + mId + "/readBy/" + myId;
      db.ref(path).set(Date.now());
    }
    function loadOlderMessages() {
      if (!currentChat || !hasMoreOld) return;
      let btn = document.getElementById("loadMoreBtn");
      btn.disabled = true;
      messagesRef.orderByChild("timestamp").endAt(oldestStamp - 1).limitToLast(50).once("value", snap => {
        let data = snap.val() || {};
        let arr = Object.entries(data).sort((a, b) => (a[1].timestamp || 0) - (b[1].timestamp || 0));
        if (arr.length < 1) {
          showNotice("No older messages found!");
          hasMoreOld = false;
          btn.style.display = "none";
          btn.disabled = false;
          return;
        }
        oldestStamp = arr[0][1].timestamp;
        arr.forEach(([mId, mVal]) => createBubble(mId, mVal, false));
        if (arr.length < 50) { hasMoreOld = false; btn.style.display = "none"; }
        arr.forEach(([mId, mVal]) => markMsgRead(mId, mVal));
        btn.disabled = false;
      });
    }
    
    // ========== Typing & Emoji ==========
    function attachTypingListener() {
      if (!currentChat || currentType === "help") return;
      let path = (currentType === "group" ? "groupChats" : "privateChats") + "/" + currentChat + "/typing";
      db.ref(path).off();
      db.ref(path).on("value", snap => {
        let val = snap.val();
        let t = document.getElementById("typingIndicator");
        if (currentChat && val && val !== displayName) { t.style.display = "block"; t.textContent = val + " is typing..."; }
        else { t.style.display = "none"; }
      });
    }
    function sendTyping() {
      if (!currentChat || currentType === "help") return;
      let path = (currentType === "group" ? "groupChats" : "privateChats") + "/" + currentChat + "/typing";
      db.ref(path).set(displayName);
      setTimeout(() => db.ref(path).set(""), 2000);
    }
    
    // ========== Slash Commands & Autocomplete ==========
    function slashAutoInput(e) {
      let val = e.target.value;
      let sc = document.getElementById("slashAutocomplete");
      if (!val.startsWith("/")) { sc.style.display = "none"; return; }
      sc.innerHTML = "";
      let rect = e.target.getBoundingClientRect();
      sc.style.left = rect.left + "px";
      sc.style.top = rect.top - 115 + "px";
      let hits = slashCmds.filter(c => c.startsWith(val));
      if (!hits.length) { sc.style.display = "none"; return; }
      hits.slice(0, 8).forEach(cmd => {
        let b = document.createElement("button");
        b.textContent = cmd;
        b.onclick = () => { e.target.value = cmd + " "; sc.style.display = "none"; };
        sc.appendChild(b);
      });
      sc.style.display = "block";
    }
    
    // ========== Message Sending ==========
    function canSendMessage() {
      let nowTime = Date.now();
      if (nowTime - lastMessageTime < 500) {
        showNotice("Please wait 0.5 seconds between messages.");
        return false;
      }
      lastMessageTime = nowTime;
      return true;
    }
    function sendMessage() {
      if (!currentChat || currentType === "help") return;
      if (!canSendMessage()) return;
      let inp = document.getElementById("msgInput");
      let txt = inp.value.trim();
      if (!txt) return;
      document.getElementById("slashAutocomplete").style.display = "none";
      if (txt.startsWith("/")) {
        processSlashCommand(txt);
        inp.value = "";
        return;
      }
      let path = (currentType === "group" ? "groupChats" : "privateChats") + "/" + currentChat + "/messages";
      db.ref(path).push({
        sender: myId,
        text: txt,
        timestamp: Date.now(),
        reaction: "",
        readBy: { [myId]: Date.now() }
      });
      inp.value = "";
      setTimeout(() => { autoScroll(); }, 50);
      sendTyping();
    }
    
    // ========== Slash Command Processing ==========
    function processSlashCommand(cmd) {
      let parts = cmd.split(" ");
      let slash = parts[0].toLowerCase();
      if (slash === "/roll") {
        let sides = parseInt(parts[1], 10) || 6;
        let r = Math.floor(Math.random() * sides) + 1;
        sendSystemMessage("ðŸŽ² Rolled a " + sides + "-sided die: " + r);
      } else if (slash === "/ping") {
        let t0 = Date.now();
        db.ref("pingTest").set({ time: t0 }, () => {
          let dt = Date.now() - t0;
          sendSystemMessage("Ping: " + dt + "ms");
        });
      } else if (slash === "/8ball") {
        let q = cmd.slice(7).trim();
        if (!q) { showNotice("Usage: /8ball [question]"); return; }
        let answers = ["Yes", "No", "Maybe", "Ask again later", "Definitely", "Certainly not"];
        let pick = answers[Math.floor(Math.random() * answers.length)];
        sendSystemMessage("8ball: " + pick);
      } else if (slash === "/roast") {
        let roasts = [
          "Your code has more bugs than a beehive.",
          "You're slower than dial-up internet.",
          "At least your chat is entertaining."
        ];
        let pick = roasts[Math.floor(Math.random() * roasts.length)];
        sendSystemMessage("Roast: " + pick);
      } else if (slash === "/tod") {
        if (parts[1] === "truth") {
          let truths = [
            "What's your biggest fear?",
            "Have you ever lied to your best friend?",
            "What's your most embarrassing moment?"
          ];
          let pick = truths[Math.floor(Math.random() * truths.length)];
          sendSystemMessage("Truth: " + pick);
        } else if (parts[1] === "dare") {
          let dares = [
            "Dance like a robot for 15 seconds.",
            "Talk in a baby voice for 3 messages.",
            "Pretend you're an alien for 10 seconds."
          ];
          let pick = dares[Math.floor(Math.random() * dares.length)];
          sendSystemMessage("Dare: " + pick);
        } else { showNotice("Usage: /tod truth or /tod dare"); }
      } else if (slash === "/title") {
        let text = parts.slice(1).join(" ");
        if (!text) { showNotice("Usage: /title [text]"); return; }
        sendSystemMessage("<< " + text + " >>");
      } else if (slash === "/cf" || slash === "/coin") {
        let guess = "";
        if (slash === "/cf") guess = parts[1] || "";
        else if (parts[1] === "flip") guess = parts[2] || "";
        guess = guess.toLowerCase();
        if (guess !== "heads" && guess !== "tails") { showNotice("Usage: /cf heads or /coin flip tails"); return; }
        let side = Math.random() < 0.5 ? "heads" : "tails";
        sendSystemMessage("Coinflip: " + side + " => you chose " + guess + " => " + (side === guess ? "You win!" : "You lose."));
      } else if (slash === "/ship") {
        let n = parts[1] || "";
        if (!n) { showNotice("Usage: /ship [name]"); return; }
        let merged = displayName.slice(0, Math.floor(displayName.length / 2)) + n.slice(Math.floor(n.length / 2));
        sendSystemMessage("Ship: " + displayName + " + " + n + " => " + merged + " ðŸ’˜");
      } else if (slash === "/rps") {
        sendSystemMessage("[RPS] " + displayName + " played rock (placeholder)");
      } else if (slash === "/guessnumber") {
        sendSystemMessage("[GuessNumber] Waiting for opponent (placeholder)");
      } else if (slash === "/vote") {
        let rest = cmd.slice(slash.length).trim();
        let parts = rest.split("|").map(x => x.trim());
        if (parts.length < 2) { showNotice("Usage: /vote question|opt1|opt2"); return; }
        let out = "Vote: " + parts[0] + "\n";
        parts.slice(1).forEach(o => { out += "- " + o + "\n"; });
        sendSystemMessage(out);
      } else {
        showNotice("Unknown slash command: " + cmd);
      }
    }
    function sendSystemMessage(text) {
      if (!currentChat || currentType === "help") return;
      let path = (currentType === "group" ? "groupChats" : "privateChats") + "/" + currentChat + "/messages";
      db.ref(path).push({
        sender: "_system",
        text: text,
        timestamp: Date.now(),
        reaction: "",
        readBy: { [myId]: Date.now() }
      });
    }
    
    // ========== Typing & Emoji ==========
    function attachTypingListener() {
      if (!currentChat || currentType === "help") return;
      let path = (currentType === "group" ? "groupChats" : "privateChats") + "/" + currentChat + "/typing";
      db.ref(path).off();
      db.ref(path).on("value", snap => {
        let val = snap.val();
        let t = document.getElementById("typingIndicator");
        if (currentChat && val && val !== displayName) { t.style.display = "block"; t.textContent = val + " is typing..."; }
        else { t.style.display = "none"; }
      });
    }
    function sendTyping() {
      if (!currentChat || currentType === "help") return;
      let path = (currentType === "group" ? "groupChats" : "privateChats") + "/" + currentChat + "/typing";
      db.ref(path).set(displayName);
      setTimeout(() => db.ref(path).set(""), 2000);
    }
    
    // ========== Initialization of Help Chat (if needed) ==========
    function setupHelpChat(){
      db.ref(`users/${myId}/chats/help_chat`).set({ name:"Help (info)", type:"help", last:0 });
    }
    
    // ========== Console Logging ==========
    console.log("All code loaded. Ready to go.");
  </script>
  
  <!-- ========== Notification Container ========== -->
  <div id="notificationContainer"></div>
  
  <!-- ========== Login Screen ========== -->
  <div id="login" style="display: flex;">
    <div style="background: var(--chat-bg); padding: 20px; border-radius: 10px; position: relative;">
      <h2>Static Live Chat</h2>
      <label>Display Name (unique):</label><br/>
      <input id="username" placeholder="Name" onkeypress="if(event.key==='Enter')doLogin()"/><br/>
      <label>Password (optional):</label><br/>
      <div style="display: flex;">
        <input id="password" type="password" style="flex: 1;" onkeypress="if(event.key==='Enter')doLogin()"/>
        <button onclick="toggleLoginPass()">ðŸ‘ï¸</button>
      </div>
      <button onclick="doLogin()">Log In</button>
    </div>
  </div>
  
  <!-- ========== Main App UI ========== -->
  <div id="app" style="display: none;">
    <div id="sidebar">
      <button onclick="openFriendsPanel()">Friends</button>
      <button onclick="addFriendUI()">Add Friend</button>
      <button onclick="showAddChatPanel()">Add Chat</button>
      <h3>Friend Requests</h3>
      <div id="requestsTab"></div>
      <div id="requestsSentTab" style="margin-top:8px; color:#ccc;"></div>
      <hr/>
      <h3>Chats</h3>
      <div id="chatList"></div>
    </div>
    <div id="chatPanel">
      <div id="topBar">
        <div id="chatTitle">No Chat</div>
        <div class="top-right">
          <button id="themeBtn" onclick="toggleTheme()">Dark: Theme</button>
          <button onclick="openSettings()">Settings</button>
        </div>
      </div>
      <div id="groupMembers" style="padding:5px 15px; display:none; font-size:14px;"></div>
      <button id="loadMoreBtn" style="display:none;" onclick="loadOlderMessages()">Load Older</button>
      <div id="messages"></div>
      <div id="typingIndicator" style="display:none;"></div>
      <div id="inputArea">
        <input id="msgInput" placeholder="Type '/' for commands" oninput="slashAutoInput(event)" onkeypress="if(event.key==='Enter'){ sendMessage(); sendTyping(); }"/>
        <button onclick="toggleEmojiPicker()">ðŸ˜€</button>
        <button onclick="sendMessage()">Send</button>
      </div>
      <div id="emojiPicker"></div>
      <div id="slashAutocomplete"></div>
    </div>
  </div>
  
  <!-- ========== Static Menu Link ========== -->
  <div id="staticMenu">
    <a href="https://sites.google.com/view/staticquasar931" target="_blank" class="staticLink">More Unblocked Games by Static</a>
  </div>
  
</body>
</html>
