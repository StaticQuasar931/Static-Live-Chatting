<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Static Live Chat â€“ Polished Edition</title>
  <!-- Firebase Scripts -->
  <script src="https://www.gstatic.com/firebasejs/11.5.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.5.0/firebase-database-compat.js"></script>
  <style>
    /* ===== Theme Variables ===== */
    :root {
      --bg-color: #111;
      --text-color: #fff;
      --sidebar-color: #1c1c1c;
      --chat-bg: #222;
      --bubble-me: #1e90ff;
      --bubble-them: #444;
      --accent: #1e90ff;
      --badge: red;
      --chat-item-bg: #333;
    }
    body.light {
      --bg-color: #f4f4f4;
      --text-color: #000;
      --sidebar-color: #ddd;
      --chat-bg: #eee;
      --bubble-me: #007aff;
      --bubble-them: #ccc;
      --accent: #007acc;
      --chat-item-bg: #bbb;
    }
    body.blue {
      --bg-color: #0b1622;
      --text-color: #f0f8ff;
      --sidebar-color: #132336;
      --chat-bg: #1e2d40;
      --bubble-me: #1f65ff;
      --bubble-them: #41546a;
      --accent: #389fff;
      --chat-item-bg: #2e3d52;
    }
    body.green {
      --bg-color: #102a10;
      --text-color: #e8ffe8;
      --sidebar-color: #224522;
      --chat-bg: #1a331a;
      --bubble-me: #28a745;
      --bubble-them: #375a37;
      --accent: #4caf50;
      --chat-item-bg: #2b442b;
    }
    body.pink {
      --bg-color: #331024;
      --text-color: #ffe0f0;
      --sidebar-color: #441533;
      --chat-bg: #551a44;
      --bubble-me: #ff3377;
      --bubble-them: #773355;
      --accent: #ff66a2;
      --chat-item-bg: #442244;
    }
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: var(--bg-color);
      color: var(--text-color);
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    input, button {
      padding: 10px;
      font-size: 16px;
      margin: 5px;
      border-radius: 6px;
      border: none;
    }
    button { background: var(--accent); color: #fff; cursor: pointer; }
    /* ===== Layout ===== */
    #app { display: flex; flex: 1; height: 100%; }
    #sidebar {
      width: 280px;
      background: var(--sidebar-color);
      display: flex;
      flex-direction: column;
      padding: 10px;
      overflow-y: auto;
    }
    #chatPanel {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: var(--chat-bg);
      position: relative;
    }
    #topBar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      font-size: 18px;
      background: var(--chat-bg);
    }
    #messages {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 15px;
      overflow-y: auto;
    }
    .msg {
      max-width: 70%;
      padding: 12px 16px;
      margin: 6px auto;
      border-radius: 20px;
      font-size: 17px;
      line-height: 1.4;
      word-wrap: break-word;
      position: relative;
      cursor: pointer;
    }
    .me { align-self: flex-end; background: var(--bubble-me); color: #fff; margin-left: auto; border-bottom-right-radius: 5px; }
    .them { align-self: flex-start; background: var(--bubble-them); color: #fff; margin-right: auto; border-bottom-left-radius: 5px; }
    .centerSys { align-self: center; background: rgba(255,255,255,0.2); font-style: italic; text-align: center; }
    .reactionTag { font-size: 14px; opacity: 0.8; position: absolute; top: 5px; right: 10px; }
    .reactionBar {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      flex-direction: row;
      gap: 5px;
      background: rgba(0,0,0,0.6);
      padding: 5px;
      border-radius: 6px;
      margin-bottom: 5px;
    }
    .reactionBar span { font-size: 22px; cursor: pointer; }
    .timestamp { position: absolute; font-size: 10px; opacity: 0.7; bottom: -14px; }
    .mineTime { right: 10px; }
    .otherTime { left: 10px; }
    #typingIndicator { display: none; font-style: italic; font-size: 14px; margin: 0 20px 10px; }
    #inputArea { display: flex; padding: 10px; background: var(--sidebar-color); }
    #inputArea input { flex: 1; margin-right: 5px; font-size: 17px; }
    #emojiPicker {
      display: none;
      position: absolute;
      bottom: 70px;
      right: 15px;
      background: var(--chat-bg);
      padding: 10px;
      flex-wrap: wrap;
      z-index: 99;
      max-width: 340px;
      max-height: 180px;
      overflow: auto;
    }
    #emojiPicker span { font-size: 22px; margin: 6px; cursor: pointer; }
    .chatItem {
      background: var(--chat-item-bg);
      padding: 10px;
      border-radius: 6px;
      margin-bottom: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      transition: background 0.2s;
    }
    .chatItem:hover { background: var(--bubble-them); }
    .chatItem.active { outline: 2px solid var(--accent); }
    .chatBadge { background: var(--badge); color: #fff; font-size: 12px; padding: 3px 8px; border-radius: 12px; margin-left: 5px; }
    .requestItem { background: var(--bubble-them); padding: 10px; margin-bottom: 5px; border-radius: 6px; }
    #staticMenu {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: #1e1e1e;
      color: #fff;
      padding: 5px 8px;
      border-radius: 8px;
      font-size: 13px;
      box-shadow: 0 0 6px #0ff;
      animation: blink 2s infinite;
      z-index: 1000;
    }
    a.staticLink { color: #0ff; text-decoration: none; }
    @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }
    /* ===== Modal Styles ===== */
    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 999;
    }
    .modalContent {
      background: var(--chat-bg);
      padding: 20px;
      border-radius: 10px;
      max-width: 400px;
      position: relative;
    }
    .closeBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: red;
      color: #fff;
      border: none;
      cursor: pointer;
      border-radius: 4px;
      padding: 3px 8px;
    }
    /* ===== Login Screen ===== */
    #login {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.7);
      z-index: 999;
    }
    /* ===== Slash Command Autocomplete ===== */
    #slashAutocomplete {
      display: none;
      position: absolute;
      background: var(--chat-bg);
      border-radius: 6px;
      padding: 5px;
      max-width: 220px;
      z-index: 9999;
    }
    #slashAutocomplete button {
      width: 100%;
      display: block;
      text-align: left;
      margin: 5px 0;
      padding: 6px;
      border-radius: 4px;
      border: none;
      background: var(--accent);
      cursor: pointer;
    }
    #loadMoreBtn {
      display: none;
      position: absolute;
      top: 15px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--accent);
      color: #fff;
      border: none;
      border-radius: 6px;
      padding: 5px;
      cursor: pointer;
      opacity: 0.8;
      z-index: 10;
    }
  </style>
</head>
<body>
<script>
  /*********************
   * Firebase Setup
   *********************/
  if(typeof firebase==="undefined"){
    console.error("Firebase not loaded â€“ check network or blocking.");
    window.firebase = { initializeApp:()=>{}, database:()=>({ ref:()=>({}) }) };
  }
  let db = null;
  try {
    const config = {
      apiKey: "YOUR_API_KEY_HERE",
      authDomain: "static-live-chatting.firebaseapp.com",
      databaseURL: "https://static-live-chatting-default-rtdb.firebaseio.com",
      projectId: "static-live-chatting",
      storageBucket: "static-live-chatting.appspot.com",
      messagingSenderId: "578562140653",
      appId: "1:578562140653:web:c12df07155627083e9dfe4"
    };
    firebase.initializeApp(config);
    db = firebase.database();
  } catch(e) {
    console.error("Firebase init error:", e);
    db = { ref: ()=>({ once: ()=>{}, on: ()=>{}, set: ()=>{}, push: ()=>({}) }) };
  }
  
  /*********************
   * Device & User Setup
   *********************/
  function genId(){ return "dev_"+Math.random().toString(36).slice(2)+"_"+Date.now(); }
  let myId = localStorage.getItem("myDeviceId");
  if(!myId){ myId = genId(); localStorage.setItem("myDeviceId", myId); }
  let displayName = localStorage.getItem("displayName") || "";
  let pass = localStorage.getItem("pass") || "";
  
  /*********************
   * Global Variables
   *********************/
  let currentChat = "", currentType = "";
  let messagesRef = null, childAddedRef = null, childChangedRef = null;
  let oldestStamp = Number.MAX_SAFE_INTEGER, hasMoreOld = false;
  let chatUnread = {};
  let blocked = {}, friends = {};
  
  // Game state objects (stored per chat in Firebase "games" nodes)
  // For simplicity, we use a subpath under each chat's messages for active games.
  
  /*********************
   * On Load Initialization
   *********************/
  window.addEventListener("DOMContentLoaded", () => {
    if(displayName){
      document.getElementById("login").style.display = "none";
      document.getElementById("app").style.display = "flex";
      applyTheme();
      loadBlocked(); loadFriends(); loadRequests(); initChatWatchers();
      setupHelpChat();
    }
  });
  
  /*********************
   * Login & Settings
   *********************/
  function toggleLoginPass(){
    let pw = document.getElementById("password");
    pw.type = (pw.type === "password") ? "text" : "password";
  }
  
  function doLogin(){
    let nm = document.getElementById("username").value.trim();
    let p = document.getElementById("password").value.trim();
    if(!nm){ showNotice("Name cannot be empty!"); return; }
    db.ref("displayNames/" + nm).once("value", snap => {
      let val = snap.val();
      if(val && val !== myId){
        showNotice("That display name is used by another device!"); 
        return;
      }
      displayName = nm; pass = p;
      localStorage.setItem("displayName", nm);
      localStorage.setItem("pass", p);
      db.ref("displayNames/" + nm).set(myId);
      db.ref("users/" + myId + "/displayName").set(nm);
      document.getElementById("login").style.display = "none";
      document.getElementById("app").style.display = "flex";
      applyTheme(); loadBlocked(); loadFriends(); loadRequests(); initChatWatchers();
      setupHelpChat();
      showNotice("Logged in as " + nm);
    });
  }
  
  function openSettings(){
    let mo = document.createElement("div");
    mo.className = "modal";
    mo.innerHTML = `
      <div class="modalContent" style="min-width:320px;">
        <button class="closeBtn" onclick="document.body.removeChild(this.parentElement.parentElement)">X</button>
        <h3>Settings</h3>
        <label>Display Name:</label><br/>
        <input id="editName" value="${displayName}"/><br/>
        <label>Password (for friend requests):</label><br/>
        <input id="editPass" value="${pass}"/><br/>
        <button id="saveSetBtn">Save</button>
        <hr/>
        <h4>Blocked Users</h4>
        <div id="blockedList"></div>
        <hr/>
        <button id="logoutBtn" style="background:darkred;">Log Out</button>
      </div>
    `;
    document.body.appendChild(mo);
    mo.style.display = "flex";
    mo.addEventListener("click", (ev) => { if(ev.target === mo) document.body.removeChild(mo); });
    mo.querySelector("#saveSetBtn").onclick = () => {
      let newN = mo.querySelector("#editName").value.trim();
      let newP = mo.querySelector("#editPass").value.trim();
      if(!newN){ showNotice("Name cannot be empty!"); return; }
      db.ref("displayNames/" + newN).once("value", snap => {
        let val = snap.val();
        if(val && val !== myId){
          showNotice("That name is used by another device!");
          return;
        }
        displayName = newN; pass = newP;
        localStorage.setItem("displayName", newN);
        localStorage.setItem("pass", newP);
        db.ref("displayNames/" + newN).set(myId);
        db.ref("users/" + myId + "/displayName").set(newN);
        showNotice("Settings saved!");
        document.body.removeChild(mo);
      });
    };
    mo.querySelector("#logoutBtn").onclick = () => {
      showConfirm("Are you sure you want to log out?", () => {
        localStorage.removeItem("myDeviceId");
        localStorage.removeItem("displayName");
        localStorage.removeItem("pass");
        location.reload();
      });
    };
    // Load blocked users into settings
    loadBlockedForSettings(mo.querySelector("#blockedList"));
  }
  
  function loadBlockedForSettings(container){
    db.ref("users/" + myId + "/blocked").once("value", snap => {
      let list = snap.val() || {};
      container.innerHTML = "";
      if(Object.keys(list).length === 0) {
        container.textContent = "No blocked users.";
      } else {
        Object.keys(list).forEach(user => {
          let div = document.createElement("div");
          div.textContent = user;
          let unblk = document.createElement("button");
          unblk.textContent = "Unblock";
          unblk.onclick = () => {
            db.ref("users/" + myId + "/blocked/" + user).remove();
            showNotice(user + " has been unblocked.");
            loadBlockedForSettings(container);
          };
          div.appendChild(unblk);
          container.appendChild(div);
        });
      }
    });
  }
  
  /*********************
   * Theming Functions
   *********************/
  function applyTheme(){
    let themes = ["dark","light","blue","green","pink"];
    let saved = localStorage.getItem("theme") || "dark";
    document.body.classList.remove(...themes);
    if(saved !== "dark") document.body.classList.add(saved);
    setThemeLabel(saved);
  }
  function toggleTheme(){
    let themes = ["dark","light","blue","green","pink"];
    let current = themes.find(t => document.body.classList.contains(t)) || "dark";
    let idx = themes.indexOf(current);
    let next = themes[(idx + 1) % themes.length];
    document.body.classList.remove(...themes);
    if(next !== "dark") document.body.classList.add(next);
    localStorage.setItem("theme", next);
    setThemeLabel(next);
  }
  function setThemeLabel(lab){
    document.getElementById("themeBtn").textContent = `${lab}: Theme`;
  }
  
  /*********************
   * Chat & Message Watchers
   *********************/
  function loadRequests(){
    // Friend requests watchers
    db.ref("users/" + myId + "/requests").on("value", snap => {
      let data = snap.val() || {};
      let tab = document.getElementById("requestsTab");
      tab.innerHTML = "";
      Object.keys(data).forEach(from => {
        let div = document.createElement("div");
        div.className = "requestItem";
        div.textContent = `${from} wants to chat. `;
        let accept = document.createElement("button");
        accept.textContent = "âœ”";
        accept.style.background = "green";
        accept.onclick = () => {
          if(blocked[from]){ showNotice("Unblock them first!"); return; }
          db.ref("displayNames/" + from).once("value", sn => {
            let dev = sn.val();
            if(!dev){ showNotice("User not found!"); return; }
            let cid = [myId, dev].sort().join("_");
            db.ref("privateChats/" + cid).set({});
            db.ref("users/" + myId + "/chats/" + cid).set({ name: from, type: "private", last: Date.now() });
            db.ref("users/" + myId + "/requests/" + from).remove();
            db.ref("users/" + myId + "/friends/" + from).set(true);
            db.ref("users/" + dev + "/friends/" + displayName).set(true);
            db.ref("users/" + dev + "/requestsSent/" + displayName).remove();
            openChat(cid, from, "private");
          });
        };
        div.appendChild(accept);
        let deny = document.createElement("button");
        deny.textContent = "âœ˜";
        deny.style.background = "red";
        deny.onclick = () => db.ref("users/" + myId + "/requests/" + from).remove();
        div.appendChild(deny);
        tab.appendChild(div);
      });
    });
    db.ref("users/" + myId + "/requestsSent").on("value", snap => {
      let st = document.getElementById("requestsSentTab");
      st.innerHTML = "<strong>Requests Sent:</strong><br/>";
      let out = snap.val() || {};
      Object.keys(out).forEach(n => {
        let div = document.createElement("div");
        div.className = "requestItem";
        div.textContent = `(Pending) ${n} `;
        let btn = document.createElement("button");
        btn.textContent = "Cancel";
        btn.onclick = () => {
          db.ref("users/" + myId + "/requestsSent/" + n).remove();
          db.ref("displayNames/" + n).once("value", sn => {
            let dev = sn.val();
            if(dev) db.ref("users/" + dev + "/requests/" + displayName).remove();
          });
        };
        div.appendChild(btn);
        st.appendChild(div);
      });
    });
    db.ref("users/" + myId + "/accepted").on("child_added", snap => {
      let who = snap.key;
      showNotice(who + " accepted your request!");
      db.ref("users/" + myId + "/requestsSent/" + who).remove();
      db.ref("displayNames/" + who).once("value", sn => {
        let dev = sn.val();
        if(!dev) return;
        let cid = [myId, dev].sort().join("_");
        db.ref("privateChats/" + cid).once("value", sn2 => {
          if(!sn2.exists()) db.ref("privateChats/" + cid).set({});
        });
        db.ref("users/" + myId + "/chats/" + cid).set({ name: who, type: "private", last: Date.now() });
      });
      setTimeout(() => db.ref("users/" + myId + "/accepted/" + who).remove(), 3000);
    });
  }
  
  function loadBlocked(){
    db.ref("users/" + myId + "/blocked").on("value", snap => {
      blocked = snap.val() || {};
    });
  }
  function loadFriends(){
    db.ref("users/" + myId + "/friends").on("value", snap => {
      friends = snap.val() || {};
    });
  }
  
  function initChatWatchers(){
    db.ref("users/" + myId + "/chats").on("value", snap => {
      let chats = snap.val() || {};
      attachAllChatWatchers(chats);
      updateChatListUI(chats);
    });
  }
  
  function attachAllChatWatchers(chats){
    Object.keys(chats).forEach(cid => {
      if(cid === "help_chat") return;
      let info = chats[cid];
      let path = (info.type === "group" ? "groupChats" : "privateChats") + "/" + cid + "/messages";
      db.ref(path).off("child_added", handleMsg);
      db.ref(path).on("child_added", handleMsg);
      function handleMsg(snap) {
        if(cid === currentChat) return;
        chatUnread[cid] = (chatUnread[cid] || 0) + 1;
        updateChatListUI(chats);
      }
    });
  }
  
  function updateChatListUI(chats){
    let arr = Object.entries(chats).sort((a,b) => {
      if(a[0] === "help_chat") return 1;
      if(b[0] === "help_chat") return -1;
      return (b[1].last || 0) - (a[1].last || 0);
    });
    let cl = document.getElementById("chatList");
    cl.innerHTML = "";
    arr.forEach(([cid, info]) => {
      let div = document.createElement("div");
      div.className = "chatItem";
      if(cid === currentChat) div.classList.add("active");
      let nm = info.name || cid;
      if(info.type === "private" && blocked[nm]) nm += " [Blocked]";
      if(info.type === "help") nm = "Help (info)";
      div.textContent = nm;
      let right = document.createElement("div");
      right.style.display = "flex";
      right.style.alignItems = "center";
      if(chatUnread[cid]){
        let badge = document.createElement("span");
        badge.className = "chatBadge";
        badge.textContent = "+" + chatUnread[cid];
        right.appendChild(badge);
      }
      if(info.type !== "help"){
        let del = document.createElement("button");
        del.textContent = "ðŸ—‘";
        del.onclick = (ev) => {
          ev.stopPropagation();
          confirmDeleteChat(cid, info);
        };
        right.appendChild(del);
      }
      div.appendChild(right);
      div.onclick = () => {
        if(info.type === "help") openHelpChat();
        else openChat(cid, nm, info.type);
      };
      cl.appendChild(div);
    });
  }
  
  function confirmDeleteChat(cid, info){
    if(info.type === "group"){
      db.ref("groupChats/" + cid + "/createdBy").once("value", snap => {
        let own = snap.val();
        if(own !== myId){
          showConfirm("Leave group " + info.name + "?", () => {
            db.ref("groupChats/" + cid + "/members/" + myId).remove();
            db.ref("users/" + myId + "/chats/" + cid).remove();
            showNotice("Left group chat successfully.");
          });
        } else {
          showConfirm("Delete group " + info.name + "?", () => {
            db.ref("groupChats/" + cid).remove();
            db.ref("users/" + myId + "/chats/" + cid).remove();
            showNotice("Group chat deleted for all members!");
          });
        }
      });
    } else {
      showConfirm("Remove private chat with " + info.name + "?", () => {
        db.ref("users/" + myId + "/chats/" + cid).remove();
        showNotice("Private chat removed from your side.");
      });
    }
  }
  
  function openChat(cid, name, type){
    currentChat = cid; currentType = type;
    chatUnread[cid] = 0;
    updateChatListUI({});
    document.getElementById("chatTitle").textContent = name;
    let gm = document.getElementById("groupMembers");
    gm.style.display = (type === "group") ? "block" : "none";
    let inp = document.getElementById("msgInput");
    inp.disabled = (type === "help");
    let area = document.getElementById("messages");
    area.innerHTML = "";
    document.getElementById("loadMoreBtn").style.display = "none";
    if(messagesRef){
      if(childAddedRef) messagesRef.off("child_added", childAddedRef);
      if(childChangedRef) messagesRef.off("child_changed", childChangedRef);
    }
    let path = (type === "group" ? "groupChats" : "privateChats") + "/" + cid + "/messages";
    messagesRef = db.ref(path);
    messagesRef.orderByChild("timestamp").limitToLast(50).once("value", snap => {
      let data = snap.val() || {};
      let arr = Object.entries(data).sort((a,b) => (a[1].timestamp||0) - (b[1].timestamp||0));
      oldestStamp = (arr.length > 0 ? arr[0][1].timestamp : Number.MAX_SAFE_INTEGER);
      arr.forEach(([mId, mVal]) => createBubble(mId, mVal, true));
      if(arr.length >= 50){
        hasMoreOld = true;
        document.getElementById("loadMoreBtn").style.display = "block";
      } else {
        hasMoreOld = false;
      }
      childAddedRef = messagesRef.orderByChild("timestamp").startAt(Date.now()).on("child_added", snap => {
        let v = snap.val();
        createBubble(snap.key, v, true);
        area.scrollTop = area.scrollHeight;
        markMsgRead(snap.key, v);
        // Also check for game responses in active game states
        processActiveGames(snap.key, v);
      });
      childChangedRef = messagesRef.on("child_changed", snap => {
        updateBubble(snap.key, snap.val());
      });
      area.scrollTop = area.scrollHeight;
      db.ref("users/" + myId + "/chats/" + cid + "/last").set(Date.now());
      arr.forEach(([mId, mVal]) => markMsgRead(mId, mVal));
    });
    if(type === "group"){
      db.ref("groupChats/" + cid + "/members").on("value", snap => {
        let members = Object.keys(snap.val() || {});
        gm.textContent = "Members: " + members.join(", ");
      });
    }
    attachTypingListener();
  }
  
  function markMsgRead(mId, val){
    if(!currentChat || currentType === "help") return;
    let p = (currentType === "group" ? "groupChats" : "privateChats") + "/" + currentChat + "/messages/" + mId + "/readBy/" + myId;
    db.ref(p).set(Date.now());
  }
  
  function loadOlderMessages(){
    if(!currentChat || !hasMoreOld) return;
    let btn = document.getElementById("loadMoreBtn");
    btn.disabled = true;
    messagesRef.orderByChild("timestamp").endAt(oldestStamp - 1).limitToLast(50).once("value", snap => {
      let data = snap.val() || {};
      let arr = Object.entries(data).sort((a,b) => (a[1].timestamp||0) - (b[1].timestamp||0));
      if(arr.length < 1){
        showNotice("No older messages found!");
        hasMoreOld = false;
        btn.style.display = "none";
        btn.disabled = false;
        return;
      }
      oldestStamp = arr[0][1].timestamp;
      arr.forEach(([mId, mVal]) => createBubble(mId, mVal, false));
      if(arr.length < 50){
        hasMoreOld = false;
        btn.style.display = "none";
      }
      arr.forEach(([mId, mVal]) => markMsgRead(mId, mVal));
      btn.disabled = false;
    });
  }
  
  function createBubble(mId, val, toEnd){
    let area = document.getElementById("messages");
    if(document.getElementById("msg_" + mId)) return;
    let bubble = document.createElement("div");
    bubble.id = "msg_" + mId;
    bubble.className = "msg";
    if(val.sender === myId) bubble.classList.add("me");
    else if(val.sender === "_system") bubble.classList.add("centerSys");
    else bubble.classList.add("them");
    // If group chat and not system, show sender name bold (if available)
    if(currentType === "group" && val.sender !== myId && val.sender !== "_system"){
      bubble.innerHTML = `<strong>${val.sender}:</strong> ` + (val.text || "");
    } else {
      bubble.innerHTML = val.text || "";
    }
    let rt = document.createElement("span");
    rt.className = "reactionTag";
    if(val.reaction) rt.textContent = val.reaction;
    bubble.appendChild(rt);
  
    let rBar = document.createElement("div");
    rBar.className = "reactionBar";
    ["â¤ï¸","ðŸ‘","ðŸ˜‚","ðŸ˜®","ðŸ˜¢"].forEach(emoji => {
      let span = document.createElement("span");
      span.textContent = emoji;
      span.onclick = (ev) => { ev.stopPropagation(); applyReaction(mId, emoji); rBar.style.display = "none"; };
      rBar.appendChild(span);
    });
    bubble.appendChild(rBar);
    bubble.addEventListener("dblclick", () => { rBar.style.display = (rBar.style.display === "flex") ? "none" : "flex"; });
    bubble.addEventListener("contextmenu", (ev) => {
      ev.preventDefault();
      if(currentType === "group"){
        db.ref("groupChats/" + currentChat + "/createdBy").once("value", snap => {
          if(snap.val() === myId){
            showConfirm("Remove this message?", () => {
              db.ref("groupChats/" + currentChat + "/messages/" + mId).remove();
              let el = document.getElementById("msg_" + mId);
              if(el) el.remove();
            });
          }
        });
      }
    });
    let ts = document.createElement("div");
    ts.className = "timestamp";
    let t = (val.timestamp ? new Date(val.timestamp).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }) : "");
    ts.textContent = t;
    bubble.appendChild(ts);
    if(val.sender === myId) ts.classList.add("mineTime"); else ts.classList.add("otherTime");
    if(toEnd) area.appendChild(bubble); else area.prepend(bubble);
    area.scrollTop = area.scrollHeight;
  }
  
  function updateBubble(mId, val){
    let b = document.getElementById("msg_" + mId);
    if(!b) return;
    let rt = b.querySelector(".reactionTag");
    if(rt) rt.textContent = val.reaction || "";
  }
  
  /*********************
   * Typing & Emoji
   *********************/
  function attachTypingListener(){
    if(!currentChat || currentType === "help") return;
    let path = (currentType === "group" ? "groupChats" : "privateChats") + "/" + currentChat + "/typing";
    db.ref(path).off();
    db.ref(path).on("value", snap => {
      let val = snap.val();
      let t = document.getElementById("typingIndicator");
      if(val && val !== displayName){
        t.style.display = "block";
        t.textContent = val + " is typing...";
      } else {
        t.style.display = "none";
      }
    });
  }
  
  function sendTyping(){
    if(!currentChat || currentType === "help") return;
    let path = (currentType === "group" ? "groupChats" : "privateChats") + "/" + currentChat + "/typing";
    db.ref(path).set(displayName);
    setTimeout(() => db.ref(path).set(""), 2000);
  }
  
  function toggleEmojiPicker(){
    let ep = document.getElementById("emojiPicker");
    if(ep.style.display === "flex"){ ep.style.display = "none"; return; }
    ep.innerHTML = "";
    ep.style.display = "flex";
    let emojis = [..."ðŸ˜€ðŸ˜ƒðŸ˜„ðŸ˜ðŸ˜†ðŸ˜…ðŸ˜‚ðŸ¤£ðŸ˜ŠðŸ˜‡ðŸ™‚ðŸ™ƒðŸ˜‰ðŸ˜ŒðŸ˜ðŸ˜˜ðŸ¥°ðŸ˜—ðŸ˜™ðŸ˜šðŸ˜‹ðŸ˜›ðŸ˜ðŸ˜œðŸ¤ªðŸ¤¨ðŸ§ðŸ¤“ðŸ˜ŽðŸ¥¸ðŸ¤©ðŸ¥³ðŸ˜ðŸ˜’ðŸ˜žðŸ˜”ðŸ˜ŸðŸ˜•ðŸ™â˜¹ï¸ðŸ˜£ðŸ˜–ðŸ˜«ðŸ˜©ðŸ¥ºðŸ˜¢ðŸ˜­ðŸ˜¤ðŸ˜ ðŸ˜¡ðŸ¤¬ðŸ¤¯ðŸ˜³ðŸ¥µðŸ¥¶ðŸ˜±ðŸ˜¨ðŸ˜°ðŸ˜¥ðŸ˜“ðŸ¤—ðŸ¤”"];
    emojis.forEach(e => {
      let span = document.createElement("span");
      span.textContent = e;
      span.onclick = () => { document.getElementById("msgInput").value += e; ep.style.display = "none"; };
      ep.appendChild(span);
    });
  }
  
  /*********************
   * Slash Commands & Games
   *********************/
  // List of simple commands for autocomplete
  const slashCmds = [
    "/roll","/ping","/8ball","/roast","/tod truth","/tod dare",
    "/title","/cf heads","/cf tails","/coin flip heads","/coin flip tails",
    "/ship","/rps","/guessnumber","/typingrace","/vote"
  ];
  
  function slashAutoInput(e){
    let val = e.target.value;
    let sc = document.getElementById("slashAutocomplete");
    if(!val.startsWith("/")){
      sc.style.display = "none"; 
      return;
    }
    sc.innerHTML = "";
    let rect = e.target.getBoundingClientRect();
    sc.style.left = rect.left + "px";
    sc.style.top = (rect.top - 115) + "px";
    let hits = slashCmds.filter(c => c.startsWith(val));
    if(!hits.length){ sc.style.display = "none"; return; }
    hits.slice(0,8).forEach(cmd => {
      let b = document.createElement("button");
      b.textContent = cmd;
      b.onclick = () => { e.target.value = cmd + " "; sc.style.display = "none"; };
      sc.appendChild(b);
    });
    sc.style.display = "block";
  }
  
  function sendMessage(){
    if(!currentChat || currentType === "help") return;
    let inp = document.getElementById("msgInput");
    let txt = inp.value.trim();
    if(!txt) return;
    document.getElementById("slashAutocomplete").style.display = "none";
    // If message starts with a slash, process it as a command
    if(txt.startsWith("/")){
      processSlashCommand(txt);
      inp.value = "";
      return;
    }
    // Check if this message is a winning guess in an active game (e.g. typingrace, guessnumber)
    // Otherwise, send as a normal chat message.
    let path = (currentType === "group" ? "groupChats" : "privateChats") + "/" + currentChat + "/messages";
    db.ref(path).push({
      sender: myId,
      text: txt,
      timestamp: Date.now(),
      reaction: "",
      readBy: { [myId]: Date.now() }
    });
    inp.value = "";
    document.getElementById("messages").scrollTop = document.getElementById("messages").scrollHeight;
    sendTyping();
  }
  
  // Process slash commands including interactive game flows.
  function processSlashCommand(cmd){
    let parts = cmd.split(" ");
    let slash = parts[0].toLowerCase();
    if(slash === "/roll"){
      let sides = parseInt(parts[1], 10) || 6;
      let r = Math.floor(Math.random() * sides) + 1;
      sendSystemMessage(`ðŸŽ² Rolled a ${sides}-sided die: ${r}`);
    }
    else if(slash === "/ping"){
      let t0 = Date.now();
      db.ref("pingTest").set({ time: t0 }, () => {
        let dt = Date.now() - t0;
        sendSystemMessage(`Ping: ${dt}ms`);
      });
    }
    else if(slash === "/8ball"){
      let q = cmd.slice(7).trim();
      if(!q){ showNotice("Usage: /8ball [question]"); return; }
      let answers = ["Yes", "No", "Maybe", "Ask again later", "Definitely", "Certainly not"];
      let pick = answers[Math.floor(Math.random() * answers.length)];
      sendSystemMessage(`8ball: ${pick}`);
    }
    else if(slash === "/roast"){
      let roasts = [
        "Your code has more bugs than a beehive.",
        "You're slower than dial-up internet.",
        "At least your chat is entertaining."
      ];
      let pick = roasts[Math.floor(Math.random() * roasts.length)];
      sendSystemMessage(`Roast: ${pick}`);
    }
    else if(slash === "/tod"){
      if(parts[1] === "truth"){
        let truths = [
          "What's your biggest fear?",
          "Have you ever lied to your best friend?",
          "What's your most embarrassing moment?"
        ];
        let pick = truths[Math.floor(Math.random() * truths.length)];
        sendSystemMessage(`Truth: ${pick}`);
      } else if(parts[1] === "dare"){
        let dares = [
          "Dance like a robot for 15 seconds.",
          "Talk in a baby voice for the next 3 messages.",
          "Pretend you're an alien for 10 seconds."
        ];
        let pick = dares[Math.floor(Math.random() * dares.length)];
        sendSystemMessage(`Dare: ${pick}`);
      } else {
        showNotice("Usage: /tod truth or /tod dare");
      }
    }
    else if(slash === "/title"){
      let text = parts.slice(1).join(" ");
      if(!text){ showNotice("Usage: /title [text]"); return; }
      sendSystemMessage(`<< ${text} >>`);
    }
    else if(slash === "/cf" || slash === "/coin"){
      let guess = "";
      if(slash === "/cf") guess = parts[1] || "";
      else if(parts[1] === "flip") guess = parts[2] || "";
      guess = guess.toLowerCase();
      if(guess !== "heads" && guess !== "tails"){
        showNotice("Usage: /cf heads or /coin flip tails");
        return;
      }
      let side = Math.random() < 0.5 ? "heads" : "tails";
      sendSystemMessage(`Coinflip: ${side} => you chose ${guess} => ${side===guess?"You win!":"You lose."}`);
    }
    else if(slash === "/ship"){
      let n = parts[1] || "";
      if(!n){ showNotice("Usage: /ship [name]"); return; }
      let merged = displayName.slice(0, Math.floor(displayName.length/2)) + n.slice(Math.floor(n.length/2));
      sendSystemMessage(`Ship: ${displayName} + ${n} => ${merged} ðŸ’˜`);
    }
    // --- Interactive Games ---
    else if(slash === "/rps"){
      // Rock-Paper-Scissors
      // If second argument is "join", then this is a response to a pending challenge.
      if(parts[1] === "join"){
        let gameId = parts[2];
        let choice = parts[3];
        if(!gameId || !choice){ showNotice("Usage: /rps join [gameId] [rock|paper|scissors]"); return; }
        joinRPSGame(gameId, choice);
      } else {
        // Initiate a new RPS challenge.
        let choice = parts[1];
        if(!choice || !["rock","paper","scissors"].includes(choice.toLowerCase())){
          showNotice("Usage: /rps [rock|paper|scissors]");
          return;
        }
        startRPSGame(choice);
      }
    }
    else if(slash === "/guessnumber"){
      // If a guess is provided, treat it as an attempt to join an active guess game.
      if(parts.length === 2){
        let guess = parseInt(parts[1], 10);
        if(isNaN(guess)){
          showNotice("Usage: /guessnumber [number] or /guessnumber to start a game");
          return;
        }
        joinGuessNumberGame(guess);
      } else {
        // Start a new guess number game (range 1-10)
        startGuessNumberGame();
      }
    }
    else if(slash === "/typingrace"){
      // Start a new typing race game.
      startTypingRaceGame();
    }
    else if(slash === "/vote"){
      // If second argument is "vote", then record a vote.
      if(parts[1] === "vote"){
        let pollId = parts[2];
        let option = parts[3];
        if(!pollId || !option){ showNotice("Usage: /vote vote [pollId] [optionNumber]"); return; }
        votePoll(pollId, option);
      } else {
        // Create a new poll.
        let rest = cmd.slice(slash.length).trim();
        let partsPoll = rest.split("|").map(x => x.trim());
        if(partsPoll.length < 2){ showNotice("Usage: /vote question|option1|option2|..."); return; }
        createPoll(partsPoll[0], partsPoll.slice(1));
      }
    }
    else {
      showNotice("Unknown slash command: " + cmd);
    }
  }
  
  // Sends a system message into the current chat.
  function sendSystemMessage(text){
    if(!currentChat || currentType === "help") return;
    let path = (currentType === "group" ? "groupChats" : "privateChats") + "/" + currentChat + "/messages";
    db.ref(path).push({
      sender: "_system",
      text: text,
      timestamp: Date.now(),
      reaction: "",
      readBy: { [myId]: Date.now() }
    });
  }
  
  /*********************
   * RPS Game Implementation
   *********************/
  function startRPSGame(choice){
    // Create a unique game id based on chat id and timestamp.
    let gameId = "rps_" + Date.now();
    // Store game state under a dedicated node in the current chat.
    db.ref("games/rps/" + currentChat + "/" + gameId).set({
      initiator: myId,
      choice: choice.toLowerCase(),
      timestamp: Date.now(),
      status: "pending"
    });
    sendSystemMessage(`RPS Challenge [${gameId}]: ${displayName} challenges with ${choice}. To join, type: /rps join ${gameId} [rock|paper|scissors] within 30 seconds.`);
    // Set a timeout to cancel if no response in 30 seconds.
    setTimeout(() => {
      db.ref("games/rps/" + currentChat + "/" + gameId + "/status").once("value", snap => {
        if(snap.val() === "pending"){
          db.ref("games/rps/" + currentChat + "/" + gameId).remove();
          sendSystemMessage(`RPS Challenge [${gameId}] expired.`);
        }
      });
    }, 30000);
  }
  
  function joinRPSGame(gameId, choice){
    db.ref("games/rps/" + currentChat + "/" + gameId).once("value", snap => {
      let game = snap.val();
      if(!game || game.status !== "pending"){
        showNotice("This RPS game is no longer available.");
        return;
      }
      let oppChoice = choice.toLowerCase();
      if(!["rock","paper","scissors"].includes(oppChoice)){
        showNotice("Choice must be rock, paper, or scissors.");
        return;
      }
      // Determine result
      let result = determineRPSWinner(game.choice, oppChoice);
      let msg = `[RPS] ${displayName} joined challenge [${gameId}]. `;
      if(result === "draw") msg += "It's a draw!";
      else if(result === "initiator") msg += `Initiator wins! (${game.choice} beats ${oppChoice})`;
      else msg += `Challenger wins! (${oppChoice} beats ${game.choice})`;
      sendSystemMessage(msg);
      db.ref("games/rps/" + currentChat + "/" + gameId).remove();
    });
  }
  
  function determineRPSWinner(choice1, choice2){
    if(choice1 === choice2) return "draw";
    if((choice1==="rock" && choice2==="scissors") ||
       (choice1==="scissors" && choice2==="paper") ||
       (choice1==="paper" && choice2==="rock")){
      return "initiator";
    }
    return "challenger";
  }
  
  /*********************
   * Guess Number Game Implementation
   *********************/
  function startGuessNumberGame(){
    let gameId = "guess_" + Date.now();
    let answer = Math.floor(Math.random() * 10) + 1;
    db.ref("games/guessnumber/" + currentChat + "/" + gameId).set({
      initiator: myId,
      answer: answer,
      timestamp: Date.now(),
      status: "pending"
    });
    sendSystemMessage(`GuessNumber Challenge [${gameId}]: Guess the number between 1 and 10! Type: /guessnumber [your guess]. You have 30 seconds.`);
    setTimeout(() => {
      db.ref("games/guessnumber/" + currentChat + "/" + gameId + "/status").once("value", snap => {
        if(snap.val() === "pending"){
          db.ref("games/guessnumber/" + currentChat + "/" + gameId).remove();
          sendSystemMessage(`GuessNumber Challenge [${gameId}] expired. The number was ${answer}.`);
        }
      });
    }, 30000);
  }
  
  function joinGuessNumberGame(guess){
    // Check for any active guess game in the current chat.
    db.ref("games/guessnumber/" + currentChat).orderByChild("timestamp").limitToLast(1).once("value", snap => {
      let games = snap.val();
      if(!games){
        showNotice("No active GuessNumber game.");
        return;
      }
      let gameId = Object.keys(games)[0];
      let game = games[gameId];
      if(game.status !== "pending"){
        showNotice("No active GuessNumber game.");
        return;
      }
      if(parseInt(guess, 10) === game.answer){
        sendSystemMessage(`GuessNumber [${gameId}]: ${displayName} guessed correctly! The number was ${game.answer}.`);
        db.ref("games/guessnumber/" + currentChat + "/" + gameId).remove();
      } else {
        sendSystemMessage(`GuessNumber [${gameId}]: ${displayName} guessed ${guess} â€“ incorrect.`);
      }
    });
  }
  
  /*********************
   * Typing Race Game Implementation
   *********************/
  const typingPrompts = [
    "The quick brown fox jumps over the lazy dog.",
    "Pack my box with five dozen liquor jugs.",
    "How vexingly quick daft zebras jump!"
  ];
  function startTypingRaceGame(){
    let gameId = "type_" + Date.now();
    let prompt = typingPrompts[Math.floor(Math.random() * typingPrompts.length)];
    db.ref("games/typingrace/" + currentChat + "/" + gameId).set({
      initiator: myId,
      prompt: prompt,
      timestamp: Date.now(),
      status: "pending"
    });
    sendSystemMessage(`TypingRace Challenge [${gameId}]: Type exactly: "${prompt}" to win! First correct message within 60 seconds wins.`);
    setTimeout(() => {
      db.ref("games/typingrace/" + currentChat + "/" + gameId + "/status").once("value", snap => {
        if(snap.val() === "pending"){
          db.ref("games/typingrace/" + currentChat + "/" + gameId).remove();
          sendSystemMessage(`TypingRace Challenge [${gameId}] expired.`);
        }
      });
    }, 60000);
  }
  
  // Called whenever a new message arrives; check if it is a correct answer for any active game.
  function processActiveGames(mId, val){
    // Process Typing Race
    db.ref("games/typingrace/" + currentChat).once("value", snap => {
      let games = snap.val();
      if(games){
        Object.keys(games).forEach(gameId => {
          let game = games[gameId];
          if(game.status === "pending" && val.text === game.prompt){
            sendSystemMessage(`TypingRace [${gameId}]: ${displayName} wins!`);
            db.ref("games/typingrace/" + currentChat + "/" + gameId).remove();
          }
        });
      }
    });
    // (Other game responses like guessnumber are handled in their own command functions.)
  }
  
  /*********************
   * Poll (Vote) Game Implementation
   *********************/
  function createPoll(question, options){
    let pollId = "poll_" + Date.now();
    let pollData = { question: question, options: {}, timestamp: Date.now(), votes: {} };
    options.forEach((opt, idx) => { pollData.options[idx+1] = { text: opt, count: 0 }; });
    db.ref("games/vote/" + currentChat + "/" + pollId).set(pollData);
    sendSystemMessage(`Poll [${pollId}]: ${question}\nOptions:\n` + options.map((o, i) => `${i+1}: ${o}`).join("\n") + `\nTo vote, type: /vote vote ${pollId} [option number]`);
  }
  
  function votePoll(pollId, option){
    let voteRef = db.ref("games/vote/" + currentChat + "/" + pollId);
    voteRef.once("value", snap => {
      let poll = snap.val();
      if(!poll){ showNotice("Poll not found."); return; }
      // Record the vote under the voter's id (prevent duplicate voting)
      if(poll.votes && poll.votes[myId]){
        showNotice("You have already voted in this poll.");
        return;
      }
      poll.votes = poll.votes || {};
      poll.votes[myId] = option;
      // Update count for the option
      if(poll.options[option]){
        poll.options[option].count++;
      }
      voteRef.set(poll, () => {
        sendSystemMessage(`${displayName} voted option ${option} in poll [${pollId}].`);
      });
    });
  }
  
  /*********************
   * Reaction Handling
   *********************/
  function applyReaction(mId, emoji){
    if(!currentChat || currentType === "help") return;
    let path = (currentType === "group" ? "groupChats" : "privateChats") + "/" + currentChat + "/messages/" + mId + "/reaction";
    db.ref(path).set(emoji);
  }
  
  /*********************
   * Friend & Block / Add Friend UI
   *********************/
  function addFriendUI(){
    let mo = document.createElement("div");
    mo.className = "modal";
    mo.innerHTML = `
      <div class="modalContent" style="min-width:300px;">
        <button class="closeBtn" onclick="document.body.removeChild(this.parentElement.parentElement)">X</button>
        <h3>Add Friend by Name</h3>
        <input id="friendNameInput" placeholder="Friend's display name"/><br/>
        <button id="friendSendBtn">Send Request</button>
      </div>
    `;
    document.body.appendChild(mo);
    mo.style.display = "flex";
    mo.addEventListener("click", (ev) => { if(ev.target === mo) document.body.removeChild(mo); });
    mo.querySelector("#friendSendBtn").onclick = () => {
      let n = mo.querySelector("#friendNameInput").value.trim();
      if(!n){ showNotice("No name typed!"); return; }
      if(n === displayName){ showNotice("Cannot add yourself!"); return; }
      if(blocked[n]){ showNotice("You have blocked this user. Unblock first!"); return; }
      db.ref("displayNames/" + n).once("value", snap => {
        let dev = snap.val();
        if(!dev){ showNotice(`No user named ${n} found!`); return; }
        if(friends[n]){ showNotice(`You're already friends with ${n}!`); return; }
        db.ref("users/" + myId + "/requestsSent/" + n).once("value", s2 => {
          if(s2.exists()){ showNotice("Request already pending."); return; }
          db.ref("users/" + dev + "/requests/" + displayName).set({ requested: true });
          db.ref("users/" + myId + "/requestsSent/" + n).set(true);
          // Create a private chat entry for both sides.
          let cid = [myId, dev].sort().join("_");
          db.ref("privateChats/" + cid).set({});
          showNotice(`Friend request sent to ${n}.`);
          document.body.removeChild(mo);
        });
      });
    };
  }
  
  function openFriendsPanel(){
    let mo = document.createElement("div");
    mo.className = "modal";
    mo.innerHTML = `
      <div class="modalContent">
        <button class="closeBtn" onclick="document.body.removeChild(this.parentElement.parentElement)">X</button>
        <h3>Your Friends</h3>
        <div id="frList"></div>
      </div>
    `;
    document.body.appendChild(mo);
    mo.style.display = "flex";
    mo.addEventListener("click", (ev) => { if(ev.target === mo) document.body.removeChild(mo); });
    let fl = mo.querySelector("#frList");
    if(!friends || !Object.keys(friends).length){
      fl.textContent = "No friends yet!";
    } else {
      Object.keys(friends).forEach(n => {
        let d = document.createElement("div");
        d.style.background = "var(--chat-bg)";
        d.style.padding = "8px";
        d.style.marginBottom = "8px";
        d.style.borderRadius = "6px";
        d.textContent = n;
        let dotBtn = document.createElement("button");
        dotBtn.textContent = "...";
        dotBtn.style.marginLeft = "10px";
        let menu = document.createElement("div");
        menu.style.display = "none";
        menu.style.position = "absolute";
        menu.style.background = "var(--chat-bg)";
        menu.style.padding = "6px";
        menu.style.borderRadius = "6px";
        let openBtn = document.createElement("button");
        openBtn.textContent = "Open Chat";
        openBtn.onclick = () => {
          db.ref("displayNames/" + n).once("value", snap => {
            let dev = snap.val();
            if(!dev){ showNotice("User not found!"); return; }
            let cid = [myId, dev].sort().join("_");
            db.ref("privateChats/" + cid).once("value", snap2 => {
              if(!snap2.exists()) db.ref("privateChats/" + cid).set({});
            });
            db.ref("users/" + myId + "/chats/" + cid).set({ name: n, type: "private", last: Date.now() });
            openChat(cid, n, "private");
          });
          menu.style.display = "none";
        };
        menu.appendChild(openBtn);
        let unfriendBtn = document.createElement("button");
        unfriendBtn.textContent = "Unfriend";
        unfriendBtn.onclick = () => {
          showConfirm("Unfriend " + n + "?", () => {
            db.ref("users/" + myId + "/friends/" + n).remove();
            db.ref("displayNames/" + n).once("value", snap2 => {
              let dev = snap2.val();
              if(dev) db.ref("users/" + dev + "/friends/" + displayName).remove();
            });
            showNotice("Unfriended " + n);
          });
          menu.style.display = "none";
        };
        menu.appendChild(unfriendBtn);
        let blockBtn = document.createElement("button");
        blockBtn.textContent = "Block";
        blockBtn.onclick = () => {
          showConfirm("Block " + n + "?", () => {
            db.ref("users/" + myId + "/blocked/" + n).set(true);
            showNotice("Blocked " + n);
          });
          menu.style.display = "none";
        };
        menu.appendChild(blockBtn);
        dotBtn.onclick = (ev) => {
          ev.stopPropagation();
          menu.style.display = (menu.style.display === "flex") ? "none" : "flex";
          let rect = dotBtn.getBoundingClientRect();
          menu.style.left = rect.left + "px";
          menu.style.top = (rect.top + 25) + "px";
        };
        d.appendChild(dotBtn);
        d.appendChild(menu);
        fl.appendChild(d);
      });
    }
  }
  
  /*********************
   * Help Chat (Read-only)
   *********************/
  function setupHelpChat(){
    db.ref("users/" + myId + "/chats/help_chat").set({
      name: "Help (info)",
      type: "help",
      last: 0
    });
  }
  
  function openHelpChat(){
    currentChat = "help_chat"; currentType = "help";
    document.getElementById("chatTitle").textContent = "Help & Info";
    let msgs = document.getElementById("messages");
    msgs.innerHTML = "";
    let bigMsg = document.createElement("div");
    bigMsg.className = "msg centerSys";
    bigMsg.innerHTML = `
      <strong>HELP & INFO</strong><br/>
      <p>
        <code>/rps rock|paper|scissors</code> â€“ Start an RPS challenge.<br/>
        <code>/rps join [gameId] [choice]</code> â€“ Join an RPS challenge.<br/>
        <code>/roll [sides]</code> â€“ Roll a die.<br/>
        <code>/ping</code> â€“ Check ping.<br/>
        <code>/8ball [question]</code> â€“ Magic 8-ball.<br/>
        <code>/roast</code> â€“ Get roasted.<br/>
        <code>/tod truth</code> or <code>/tod dare</code> â€“ Truth or dare.<br/>
        <code>/title [text]</code> â€“ Big system message.<br/>
        <code>/cf heads/tails</code> â€“ Coin flip.<br/>
        <code>/ship [name]</code> â€“ Ship names.<br/>
        <code>/guessnumber</code> â€“ Start a GuessNumber game.<br/>
        <code>/guessnumber [number]</code> â€“ Guess in an active game.<br/>
        <code>/typingrace</code> â€“ Start a typing race.<br/>
        <code>/vote question|opt1|opt2|...</code> â€“ Create a poll.<br/>
        <code>/vote vote [pollId] [option]</code> â€“ Vote in a poll.
      </p>
    `;
    msgs.appendChild(bigMsg);
    document.getElementById("msgInput").disabled = true;
  }
  
  /*********************
   * Confirmation & Notice Modals
   *********************/
  function showConfirm(msg, yesCb){
    let mo = document.createElement("div");
    mo.className = "modal";
    mo.innerHTML = `
      <div class="modalContent" style="max-width:400px;position:relative;">
        <button class="closeBtn" onclick="document.body.removeChild(this.parentElement.parentElement)">X</button>
        <h3>Confirm</h3>
        <p>${msg}</p>
        <div style="text-align:center;">
          <button style="background:green;" id="yesBtn">Yes</button>
          <button style="background:red;" id="noBtn">No</button>
        </div>
      </div>
    `;
    document.body.appendChild(mo);
    mo.querySelector("#yesBtn").onclick = () => { document.body.removeChild(mo); yesCb(); };
    mo.querySelector("#noBtn").onclick = () => { document.body.removeChild(mo); };
  }
  
  function showNotice(msg){
    let mo = document.createElement("div");
    mo.className = "modal";
    mo.innerHTML = `
      <div class="modalContent" style="max-width:400px;position:relative;">
        <button class="closeBtn" onclick="document.body.removeChild(this.parentElement.parentElement)">X</button>
        <h3>Notice</h3>
        <p>${msg}</p>
        <div style="text-align:center;">
          <button style="background:var(--accent);" id="okBtn">OK</button>
        </div>
      </div>
    `;
    document.body.appendChild(mo);
    mo.querySelector("#okBtn").onclick = () => { document.body.removeChild(mo); };
  }
</script>

<!-- LOGIN UI -->
<div id="login" style="display:flex;">
  <div style="background:var(--chat-bg);padding:20px;border-radius:10px;position:relative;">
    <h2>Static Live Chat</h2>
    <label>Display Name (unique):</label><br/>
    <input id="username" placeholder="Your Name" onkeypress="if(event.key==='Enter')doLogin()"/><br/>
    <label>Password (optional):</label><br/>
    <div style="display:flex;">
      <input id="password" type="password" style="flex:1;" onkeypress="if(event.key==='Enter')doLogin()"/>
      <button onclick="toggleLoginPass()">ðŸ‘ï¸</button>
    </div>
    <button onclick="doLogin()">Log In</button>
  </div>
</div>

<!-- MAIN APP UI -->
<div id="app" style="display:none;">
  <div id="sidebar">
    <button onclick="openFriendsPanel()">Friends</button>
    <button onclick="addFriendUI()">Add Friend</button>
    <button onclick="openSettings()">Settings</button>
    <button onclick="showAddChatPanel()">Add Chat</button>
    <h3>Friend Requests</h3>
    <div id="requestsTab"></div>
    <div id="requestsSentTab" style="margin-top:8px;color:#ccc;"></div>
    <hr/>
    <h3>Chats</h3>
    <div id="chatList"></div>
  </div>
  <div id="chatPanel">
    <div id="topBar">
      <div id="chatTitle">No Chat</div>
      <div>
        <button id="themeBtn" onclick="toggleTheme()">Dark: Theme</button>
      </div>
    </div>
    <div id="groupMembers" style="padding:5px 15px; display:none; font-size:14px;"></div>
    <button id="loadMoreBtn" onclick="loadOlderMessages()">Load Older</button>
    <div id="messages"></div>
    <div id="typingIndicator"></div>
    <div id="inputArea">
      <input id="msgInput" placeholder="Type '/' for commands" oninput="slashAutoInput(event)" onkeypress="if(event.key==='Enter')sendMessage(); sendTyping();"/>
      <button onclick="toggleEmojiPicker()">ðŸ˜€</button>
      <button onclick="sendMessage()">Send</button>
    </div>
    <div id="emojiPicker"></div>
    <div id="slashAutocomplete"></div>
  </div>
</div>

<!-- Static Link -->
<div id="staticMenu">
  <a href="https://sites.google.com/view/staticquasar931" target="_blank" class="staticLink">More Unblocked Games by Static</a>
</div>

<!-- 
  IMPORTANT: Firebase Security Rules
  For improved security, update your Firebase rules to restrict read/write based on:
  - Only allowing writes if the displayName mapping matches the stored device ID.
  - Ensuring users can only modify their own nodes (e.g., /users/{myId}).
  Example (this is only a starting point â€“ adjust as needed):
  
  {
    "rules": {
      ".read": true,
      ".write": false,
      "displayNames": {
        "$name": {
          ".write": "data.val() === null || newData.val() === auth.uid"
        }
      },
      "users": {
        "$uid": {
          ".read": "$uid === auth.uid",
          ".write": "$uid === auth.uid"
        }
      },
      "privateChats": { ".read": true, ".write": true },
      "groupChats": { ".read": true, ".write": true },
      "games": { ".read": true, ".write": true }
    }
  }
  
  Replace auth.uid logic with your chosen mechanism. Since this app uses no formal login,
  consider generating custom tokens or another method for security.
-->
</body>
</html>
